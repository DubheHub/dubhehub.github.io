<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vector的实现</title>
    <link href="/blogs/2024060523010046412.html"/>
    <url>/blogs/2024060523010046412.html</url>
    
    <content type="html"><![CDATA[<h1 id="所谓“向量”"><a href="#所谓“向量”" class="headerlink" title="所谓“向量”"></a>所谓“向量”</h1><p>绝大多数编程语言中均提供静态数组和动态数组的实现，C++中对动态数据的实现有std::Vector，即所谓向量。</p><p>动态数组顾名思义，是存储某类数据类型的一个容器，应提供对容器内数据增删改查的能力。</p><h1 id="动态数组实现"><a href="#动态数组实现" class="headerlink" title="动态数组实现"></a>动态数组实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vector</span> &#123;</span><br>public:<br>Vector();<br>Vector(<span class="hljs-type">int</span> capaity);<br>~Vector();<br>public:<br><span class="hljs-type">bool</span> <span class="hljs-title function_">at</span><span class="hljs-params">(<span class="hljs-type">int</span> index, T* pElement)</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">push_back</span><span class="hljs-params">(T&amp; elemnt)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">pop_back</span><span class="hljs-params">()</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, T&amp; elemnt)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">capaity</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">earse</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br>private:<br><span class="hljs-type">bool</span> <span class="hljs-title function_">expand</span><span class="hljs-params">()</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">isOverLen</span><span class="hljs-params">()</span>;<br>private:<br><span class="hljs-type">int</span> m_index;<br><span class="hljs-type">int</span> m_increment;<br><span class="hljs-type">int</span> m_len;<br><span class="hljs-type">int</span> m_initSize;<br><span class="hljs-type">int</span> m_eleSize;<br>T* m_pVector;<br>&#125;;<br><br>template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br>Vector&lt;T&gt;::Vector() : m_initSize(<span class="hljs-number">10</span>), m_increment(<span class="hljs-number">5</span>) &#123;<br>this-&gt;m_pVector = new T[m_initSize];<br>m_len = m_initSize;<br>m_index = <span class="hljs-number">0</span>;<br>m_eleSize = <span class="hljs-keyword">sizeof</span>(T);<br>&#125;<br><br>template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br>Vector&lt;T&gt;::Vector(<span class="hljs-type">int</span> capaity) : m_initSize(capaity), m_increment(<span class="hljs-number">5</span>) &#123;<br>this-&gt;m_pVector = new T[m_initSize];<br>m_len = capaity;<br>m_index = <span class="hljs-number">0</span>;<br>m_eleSize = <span class="hljs-keyword">sizeof</span>(T);<br>&#125;<br><br>template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br>Vector&lt;T&gt;::~Vector() &#123;<br>delete[] this-&gt;m_pVector;<br>&#125;<br><br>template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-type">bool</span> Vector&lt;T&gt;::isOverLen() &#123;<br><span class="hljs-keyword">return</span> m_index &gt;= m_len;<br>&#125;<br><br>template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-type">bool</span> Vector&lt;T&gt;::at(<span class="hljs-type">int</span> index, T* pElement) &#123;<br><span class="hljs-keyword">if</span> (index &gt;= m_index) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>*pElement = m_pVector[index];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-type">bool</span> Vector&lt;T&gt;::push_back(T&amp; elemnt) &#123;<br><span class="hljs-keyword">if</span> (this-&gt;isOverLen() &amp;&amp; !this-&gt;expand()) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>m_pVector[m_index++] = elemnt;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-type">void</span> Vector&lt;T&gt;::pop_back() &#123;<br>m_index--;<br>&#125;<br><br>template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-type">bool</span> Vector&lt;T&gt;::insert(<span class="hljs-type">int</span> index, T&amp; elemnt) &#123;<br><span class="hljs-keyword">if</span> (index &gt; m_index) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (this-&gt;isOverLen() &amp;&amp; !this-&gt;expand()) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (index == m_index) &#123;<br>this-&gt;m_pVector[m_index++] = elemnt;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m_index; i &gt; index; i--) &#123;<br>m_pVector[i] = m_pVector[i - <span class="hljs-number">1</span>];<br>&#125;<br><br>m_pVector[index] = elemnt;<br>m_index++;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-type">int</span> Vector&lt;T&gt;::capaity() &#123;<br><span class="hljs-keyword">return</span> this-&gt;m_initSize;<br>&#125;<br><br>template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-type">void</span> Vector&lt;T&gt;::clear() &#123;<br>delete[] m_pVector;<br>this-&gt;m_index = <span class="hljs-number">0</span>;<br>this-&gt;m_len = m_initSize;<br>this-&gt;m_pVector = new T[m_initSize];<br>&#125;<br><br>template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-type">bool</span> Vector&lt;T&gt;::empty() &#123;<br><span class="hljs-keyword">return</span> this-&gt;m_index == <span class="hljs-number">0</span>;<br>&#125;<br><br>template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-type">void</span> Vector&lt;T&gt;::earse(<span class="hljs-type">int</span> index) &#123;<br><span class="hljs-keyword">if</span> (index &gt;= m_index) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; m_index; i++) &#123;<br>m_pVector[i] = m_pVector[i + <span class="hljs-number">1</span>];<br>&#125;<br>m_index--;<br>&#125;<br><br>template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-type">int</span> Vector&lt;T&gt;::size() &#123;<br><span class="hljs-keyword">return</span> m_index;<br>&#125;<br><br>template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-type">bool</span> Vector&lt;T&gt;::expand() &#123;<br><span class="hljs-type">int</span> newLen = this-&gt;m_len + this-&gt;m_increment;<br>T* newArray = new T[newLen];<br><br><span class="hljs-keyword">if</span> (newArray == nullptr) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m_len; i++) &#123;<br>newArray[i] = m_pVector[i];<br>&#125;<br>delete[] m_pVector;<br><br>m_pVector = newArray;<br>m_len = newLen;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>上善若水</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PE结构(11)导入表注入DLL</title>
    <link href="/blogs/2024051114490015619.html"/>
    <url>/blogs/2024051114490015619.html</url>
    
    <content type="html"><![CDATA[<h2 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h2><p>修改原PE文件导入表，将自己的Inject Dll追加到导入表中。</p><p>从而影响原PE文件加载时的流程，将自身Dll加载至其内存空间。</p><h2 id="流程概览"><a href="#流程概览" class="headerlink" title="流程概览"></a>流程概览</h2><ol><li>添加新节，用于将原PE文件整个导入表拷贝</li><li>在拷贝的新表中，追加一个导入项</li><li>添加需要注入的dll名字、函数名字，用以重建INT表和IAT表</li><li>修改原PE结构的数据页目录，将导入表地址RVA指向新表</li><li>dump存盘，尝试运行</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">work08</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//将指定文件加载到内存，并解析PE信息到PEFILE结构体</span><br>PEFILE peFile&#123; <span class="hljs-number">0</span> &#125;;<br>FILE* pFile = fopen(<span class="hljs-string">&quot;D:\\1.exe&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br><br><span class="hljs-type">int</span> fileLength = LoadFileToMemory(pFile, &amp;peFile);<br><span class="hljs-type">int</span> r = fclose(pFile);<br><br><span class="hljs-keyword">if</span> (peFile.h_pe == nullptr) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>DWORD bufferImageBase = (DWORD)peFile.h_dos;<br><br><span class="hljs-comment">//获取导入表</span><br>PDATA_IMPORT_DIRECTORY pImportTable = nullptr;<br>GetImportTable(&amp;pImportTable, &amp;peFile);<br><br><span class="hljs-comment">//第一步，添加节</span><br>lpPETable newTable = (lpPETable)AddSection(&amp;peFile, (<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;.crack&quot;</span>, <span class="hljs-number">0x1000</span>);<br><span class="hljs-keyword">if</span> (newTable == nullptr) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>DWORD index = bufferImageBase + newTable-&gt;PointerToRawData;<br><span class="hljs-comment">//设置注入dll的名字</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* dllName = <span class="hljs-string">&quot;TestDLL.dll&quot;</span>;<br>DWORD dllNameFOA = index - bufferImageBase;<br>DWORD dllNameRVA = Foa2Rva(dllNameFOA, &amp;peFile);<br><span class="hljs-built_in">memcpy</span>((LPVOID)index, dllName, <span class="hljs-built_in">strlen</span>(dllName) + <span class="hljs-number">1</span>);<br>index += <span class="hljs-built_in">strlen</span>(dllName) + <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//第二步，拷贝导入表</span><br><span class="hljs-type">int</span> importTableIndex = <span class="hljs-number">0</span>;<br>PDATA_IMPORT_DIRECTORY pNewImportTable = (PDATA_IMPORT_DIRECTORY)index;<br><span class="hljs-keyword">while</span> ((pImportTable + importTableIndex)-&gt;Characteristics != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">memcpy</span>(<br>pNewImportTable + importTableIndex, <br>pImportTable + importTableIndex, <br><span class="hljs-keyword">sizeof</span>(DATA_IMPORT_DIRECTORY)<br>);<br>index += <span class="hljs-keyword">sizeof</span>(DATA_IMPORT_DIRECTORY);<br>importTableIndex++;<br>&#125;<br><br><span class="hljs-comment">//第三步，增加新导入表</span><br>PDATA_IMPORT_DIRECTORY newImportDirectory = (PDATA_IMPORT_DIRECTORY)index;<br>index += <span class="hljs-keyword">sizeof</span>(DATA_IMPORT_DIRECTORY);<br><span class="hljs-comment">//添加一段空结构作为结束</span><br><span class="hljs-built_in">memset</span>((LPVOID)index, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(DATA_IMPORT_DIRECTORY));<br>index += <span class="hljs-keyword">sizeof</span>(DATA_IMPORT_DIRECTORY);<br><br><span class="hljs-comment">//第四步，增加导入函数名</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* funcNameStr = <span class="hljs-string">&quot;mul&quot;</span>;<br>PDATA_IMPORT_BY_NAME funcName = (PDATA_IMPORT_BY_NAME)index;<br>DWORD funcNameRVA = Foa2Rva((DWORD)funcName - bufferImageBase, &amp;peFile);<br>funcName-&gt;Hint = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memcpy</span>(funcName-&gt;Name, funcNameStr, <span class="hljs-built_in">strlen</span>(funcNameStr) + <span class="hljs-number">1</span>);<br>index += <span class="hljs-keyword">sizeof</span>(WORD) + <span class="hljs-built_in">strlen</span>(funcNameStr) + <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//第五步，增加INT与IAT结构</span><br>PDATA_THUNK_DATA lpNewINT = (PDATA_THUNK_DATA)index;<br>index += <span class="hljs-keyword">sizeof</span>(PDATA_THUNK_DATA);<br>lpNewINT-&gt;AddressOfData = funcNameRVA;<br><span class="hljs-built_in">memset</span>((LPVOID)index, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PDATA_THUNK_DATA));<br>index += <span class="hljs-keyword">sizeof</span>(PDATA_THUNK_DATA);<br><br>PDATA_THUNK_DATA lpNewIAT = (PDATA_THUNK_DATA)index;<br>index += <span class="hljs-keyword">sizeof</span>(PDATA_THUNK_DATA);<br>lpNewIAT-&gt;AddressOfData = funcNameRVA;<br><span class="hljs-built_in">memset</span>((LPVOID)index, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PDATA_THUNK_DATA));<br>index += <span class="hljs-keyword">sizeof</span>(PDATA_THUNK_DATA);<br><br><span class="hljs-comment">//第六步，修复INT与IAT</span><br>newImportDirectory-&gt;Name = dllNameRVA;<br>newImportDirectory-&gt;OriginalFirstThunk = Foa2Rva((DWORD)lpNewINT - bufferImageBase, &amp;peFile);<br>newImportDirectory-&gt;FirstThunk = Foa2Rva((DWORD)lpNewIAT - bufferImageBase, &amp;peFile);<br>newImportDirectory-&gt;TimeDateStamp = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//第七步，修复数据目录</span><br>lpPe_DATA_DIRECTORY lpImportDirectory = &amp;peFile.h_op-&gt;DataDirectory[<span class="hljs-number">1</span>];<br>lpImportDirectory-&gt;VirtualAddress = <br>Foa2Rva((DWORD)pNewImportTable - bufferImageBase, &amp;peFile);<br><br>pFile = fopen(<span class="hljs-string">&quot;D:\\2.exe&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>);<br>DumpFileBufferToFile(pFile, &amp;peFile);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>上善若水</category>
      
      <category>PE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>PE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PE结构(10)绑定导入表</title>
    <link href="/blogs/2024051015000029832.html"/>
    <url>/blogs/2024051015000029832.html</url>
    
    <content type="html"><![CDATA[<h2 id="IAT中的奇怪地址"><a href="#IAT中的奇怪地址" class="headerlink" title="IAT中的奇怪地址"></a>IAT中的奇怪地址</h2><p>在之前的文章：<a href="https://dubhehub.github.io/blogs/202405091121009749.html">PE结构(9)导入表</a> 中，我们已对IAT结构做出了基本的解析。</p><p>目前可以达成的认识是：</p><p><strong>在PE文件加载之前，IAT与INT指向同一块函数名称空间，当PE文件加载之后，OS会将所需导入函数的绝对地址贴到IAT的地址中。</strong></p><p>那么有没有一种情况，即在PE文件加载之前，IAT中已经存储了导入函数的地址呢？</p><p>事实上这事儿完全有可能的，例如古早时期的Windows XP版本中，系统自带的画图、记事本、计算器等EXE执行文件，都是通过这种方式直接在IAT中存储了导入函数地址。</p><h2 id="IAT中函数地址的加载"><a href="#IAT中函数地址的加载" class="headerlink" title="IAT中函数地址的加载"></a>IAT中函数地址的加载</h2><p>当PE文件被装载到内存，开始计算IAT中所需的函数地址时，一个显而易见的问题就在于：依赖的DLL文件，并不能保证自身一定位于某个固定的ImageBase。</p><p>即使在OS层面没有开启入口地址随机化，也存在某个DLL计划好的ImageBase被其他DLL Module抢占，导致程序基地址发生偏差。此时OS将根据DLL内的Reloc表对DLL内的地址进行重定位修复，最终是将修复后的函数地址填入EXE文件的IAT中。</p><p>那么如果EXE里的IAT是被提前绑定的呢？当然需要重新计算了。</p><p>同理，如果DLL文件本身被修改了，导致函数地址变更，此时也需要重新计算IAT中存储的地址。</p><h2 id="绑定导入表"><a href="#绑定导入表" class="headerlink" title="绑定导入表"></a>绑定导入表</h2><p>如何进行这种计算呢？就需要绑定导入表的参与了。</p><h3 id="TimeStamp比对"><a href="#TimeStamp比对" class="headerlink" title="TimeStamp比对"></a>TimeStamp比对</h3><p>我们在之前的文章中探讨过导入表的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">DATA_IMPORT_DIRECTORY</span> &#123;</span><br>     <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>         DWORD   Characteristics;            <span class="hljs-comment">//导入表结束标志</span><br>         DWORD   OriginalFirstThunk;         <span class="hljs-comment">//RVA指向一个结构体数组(INT表)</span><br>     &#125;;<br>     DWORD   TimeDateStamp;                  <span class="hljs-comment">//时间戳,该值为0时，说明IAT表未绑定，为-1时IAT已被绑定导入函数地址</span><br>     DWORD   ForwarderChain;                 <span class="hljs-comment">// -1 if no forwarders</span><br>     DWORD   Name;                           <span class="hljs-comment">//RVA指向dll名字，以0结尾</span><br>     DWORD   FirstThunk;                     <span class="hljs-comment">//RVA指向一个结构体数组(IAT表)</span><br> &#125; DATA_IMPORT_DIRECTORY, * PDATA_IMPORT_DIRECTORY;<br></code></pre></td></tr></table></figure><p>在当时我们未对我<em>TimeDateStamp</em>成员进行过多深究。</p><p>此时则需要重新审视该成员，当该成员存储0值时，意味着IAT中尚未绑定函数地址，当该成员存储-1时，意味着IAT已绑定函数地址。</p><p>对于使用了绑定导入表技术的PE文件来说，在程序加载之前，<em>TimeDateStamp</em>的值就已经是-1了。</p><div class="note note-info">            <p>此时我们解决了第一个问题：如何判断IAT表中已经绑定了导入函数？<br>但是还未解决另一个问题，在IAT被提前（加载前）绑定时，如何确认绑定的地址是真实有效的呢？</p>          </div><h3 id="结构概述"><a href="#结构概述" class="headerlink" title="结构概述"></a>结构概述</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">DATA_BOUND_IMPORT_DESCRIPTOR</span> &#123;</span><br>     DWORD   TimeDateStamp;      <span class="hljs-comment">//表示绑定的时间戳，如果和PE头中的TimeDateStamp不同则可能被修改过</span><br>     WORD    OffsetModuleName;   <span class="hljs-comment">//dll名称地址</span><br>     WORD    NumberOfModuleForwarderRefs;    <span class="hljs-comment">//依赖dll个数</span><br> &#125; DATA_BOUND_IMPORT_DESCRIPTOR,  *PDATA_BOUND_IMPORT_DESCRIPTOR;<br><br> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">DATA_BOUND_FORWARDER_REF</span> &#123;</span><br>     DWORD   TimeDateStamp;  <span class="hljs-comment">//时间戳，同样的作用检查更新情况</span><br>     WORD    OffsetModuleName;   <span class="hljs-comment">//dll名称地址</span><br>     WORD    Reserved;   <span class="hljs-comment">//保留</span><br> &#125; DATA_BOUND_FORWARDER_REF, *PDATA_BOUND_FORWARDER_REF;<br></code></pre></td></tr></table></figure><p>该接口即为绑定导入表结构，当<em>DATA_BOUND_IMPORT_DESCRIPTOR</em>中存储的<em>TimeDateStamp</em>成员，与对应的DLL文件的标准PE头中存储的<em>TimeDateStamp</em>一致的情况下，我们认为导入函数的地址不需要重新计算（即DLL文件并未发生修改）。</p><p>很明显，为了确认这件事情，OS会需要遍历全部的绑定导入表结构，来判断是否需要将某个DLL的导出函数地址重新计算后填入EXE的IAT中。</p><h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>DATA_BOUND_IMPORT_DESCRIPTOR结构中的NumberOfModuleForwarderRefs成员，描述了该dll依赖多少个其他dll。</p><p>若该成员为0，则下一个结构体仍然是DATA_BOUND_IMPORT_DESCRIPTOR。</p><p>若该成员不为0，则下N个结构体为DATA_BOUND_FORWARDER_REF结构。</p><h3 id="DLL名称的奇怪设计"><a href="#DLL名称的奇怪设计" class="headerlink" title="DLL名称的奇怪设计"></a>DLL名称的奇怪设计</h3><p>尝试获取DATA_BOUND_FORWARDER_REF结构或DATA_BOUND_IMPORT_DESCRIPTOR结构的名称时，使用第一个DATA_BOUND_IMPORT_DESCRIPTOR结构的地址加上OffsetModuleName（无论当前遍历到第几个），即是DLL名称字符串所在地址（RVA）。</p><h2 id="编码实现打印绑定导入表"><a href="#编码实现打印绑定导入表" class="headerlink" title="编码实现打印绑定导入表"></a>编码实现打印绑定导入表</h2><p>很不容易找到一个还在用这古老技术的文件。</p><p>以下示例使用从winxp中提取的记事本程序演示。</p><p><a href="https://github.com/DubheHub/dubhehub.github.io/blob/master/img/post/2024051015000029832/notepad.exe">notepad.exe</a></p><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">work07</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//将指定文件加载到内存，并解析PE信息到PEFILE结构体</span><br>PEFILE peFile&#123; <span class="hljs-number">0</span> &#125;;<br>FILE* pFile = fopen(<span class="hljs-string">&quot;D:\\notepad.exe&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br><br><span class="hljs-type">int</span> fileLength = LoadFileToMemory(pFile, &amp;peFile);<br><span class="hljs-type">int</span> r = fclose(pFile);<br><br><span class="hljs-keyword">if</span> (peFile.h_pe == nullptr) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//获取绑定导入表</span><br>PDATA_BOUND_IMPORT_DESCRIPTOR pTable = nullptr;<br>GetBoundImportTable(&amp;pTable, &amp;peFile);<br><br>PrintBoundImportTable(pTable, &amp;peFile);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="打印绑定导入表"><a href="#打印绑定导入表" class="headerlink" title="打印绑定导入表"></a>打印绑定导入表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">PrintBoundImportTable</span><span class="hljs-params">(PDATA_BOUND_IMPORT_DESCRIPTOR table, lpPEFILE lpPefile)</span> &#123;<br><span class="hljs-keyword">if</span> (table == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>DWORD firstTableAddress = (DWORD)table;<br><br><span class="hljs-keyword">while</span> (table-&gt;TimeDateStamp != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>DWORD address = (DWORD)table;<br><span class="hljs-type">char</span>* dllName = (<span class="hljs-type">char</span>*)(table-&gt;OffsetModuleName + firstTableAddress);<br>DWORD timeStamp = table-&gt;TimeDateStamp;<br>WORD numberOfRefs = table-&gt;NumberOfModuleForwarderRefs;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address: 0x%x, dllName: %s, timeStamp: 0x%x, numberOfRefs: %d \n&quot;</span>,<br>address, dllName, timeStamp, numberOfRefs);<br><br><span class="hljs-keyword">if</span> (numberOfRefs &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Refs:\n&quot;</span>);<br>PrintBoundImportRef(<br>(PDATA_BOUND_FORWARDER_REF)(table + <span class="hljs-number">1</span>), firstTableAddress, numberOfRefs, lpPefile);<br>&#125;<br><br>table += numberOfRefs &gt; <span class="hljs-number">0</span> ? numberOfRefs + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*********************************************************************\n&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="打印Ref（其实是完全相同的结构）"><a href="#打印Ref（其实是完全相同的结构）" class="headerlink" title="打印Ref（其实是完全相同的结构）"></a>打印Ref（其实是完全相同的结构）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">PrintBoundImportRef</span><span class="hljs-params">(</span><br><span class="hljs-params">PDATA_BOUND_FORWARDER_REF table, DWORD firstTableAddress, DWORD size, lpPEFILE lpPefile)</span> &#123;<br><span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (table-&gt;TimeDateStamp != <span class="hljs-literal">NULL</span> &amp;&amp; index &lt; size) &#123;<br>DWORD address = (DWORD)table;<br><span class="hljs-type">char</span>* dllName = (<span class="hljs-type">char</span>*)(table-&gt;OffsetModuleName + firstTableAddress);<br>DWORD timeStamp = table-&gt;TimeDateStamp;<br>WORD Reserved = table-&gt;Reserved;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address: 0x%x, dllName: %s, timeStamp: 0x%x, Reserved: %d \n&quot;</span>,<br>address, dllName, timeStamp, Reserved);<br><br>table++;<br>index++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/2024051015000029832/1.png"></p>]]></content>
    
    
    <categories>
      
      <category>上善若水</category>
      
      <category>PE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>PE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PE结构(9)导入表</title>
    <link href="/blogs/202405091121009749.html"/>
    <url>/blogs/202405091121009749.html</url>
    
    <content type="html"><![CDATA[<h2 id="导入表工作原理"><a href="#导入表工作原理" class="headerlink" title="导入表工作原理"></a>导入表工作原理</h2><p>PE文件加载过程中，OS会先将文件“拉伸”，而后OS会将其“贴”在虚拟内存，此时即可根据导入表内申请的名单来寻找该Module运行所需要的其他支持。</p><p>一般来说是因为某个Module运行需要外部提供某些函数的实现支持。</p><p>导入表内描述了需要的函数的名称或者函数序号，以及这些函数位于的Module名称（一般是XXX.DLL文件），OS根据依赖的Module名称就可以将该Module也加载到内存中，并检查该Module的导出表，按序号或名称的方式从导出表中找到所需的函数地址。</p><div class="note note-info">            <p>关于从导出表内寻找函数地址，可参考过往的帖子：<br><a href="https://dubhehub.github.io/blogs/2024043014020040528.html">PE结构(4)导出表</a></p>          </div><p>当函数地址被找到后，OS即可将该函数的绝对地址直接贴回到申请导入的PE文件的导入表中（导入表中的IAT结构就专门干这事，下文会详细探讨）。</p><p>当我们联系汇编代码时，就可以想通这个道理：</p><p>静态引用的函数地址，例如某程序内部自实现的函数，其地址在汇编代码中表现为绝对地址（ImageBase + RVA）: call XXXX</p><p>动态引用的函数地址，其地址依赖外部导入，故汇编代码中表现为 call dword ptr [XXXX]。这里的XXXX即为IAT中存储导入函数地址的位置，可以理解为一个函数指针。</p><h2 id="导入表位置"><a href="#导入表位置" class="headerlink" title="导入表位置"></a>导入表位置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PE_HEADERS_OPTIONAL</span> &#123;</span><br>...<br>PE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBERSOF_DIRECTORY_ENTRY];<br>&#125;PEHOPTIONAL, *lpPEHOPTIONAL;<br></code></pre></td></tr></table></figure><p>导入表位于OP头的DataDirectory数组的第2个元素，即DataDirectory[1] 的位置，存储导入表地址。</p><blockquote><p>还记得导出表在哪里吗？正是 DataDirectory[0] 的位置。</p></blockquote><h2 id="导入表结构"><a href="#导入表结构" class="headerlink" title="导入表结构"></a>导入表结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">DATA_IMPORT_DIRECTORY</span> &#123;</span><br>     <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>         DWORD   Characteristics;            <span class="hljs-comment">//导入表结束标志</span><br>         DWORD   OriginalFirstThunk;         <span class="hljs-comment">//RVA指向一个结构体数组(INT表)</span><br>     &#125;;<br>     DWORD   TimeDateStamp;                  <span class="hljs-comment">//时间戳,该值为0时，说明IAT表未提前绑定，为-1时IAT已被绑定导入表提前导入函数地址</span><br>     DWORD   ForwarderChain;                 <span class="hljs-comment">// -1 if no forwarders</span><br>     DWORD   Name;                           <span class="hljs-comment">//RVA指向dll名字，以0结尾</span><br>     DWORD   FirstThunk;                     <span class="hljs-comment">//RVA指向一个结构体数组(IAT表)</span><br> &#125; DATA_IMPORT_DIRECTORY, * PDATA_IMPORT_DIRECTORY;<br></code></pre></td></tr></table></figure><p>一个PE程序会依赖多少外部的DLL ？ 不知道，可能是一个，也可能是多个。</p><p>因此导入表注定不会只有一张，往往会有多张。</p><p>通过结构体的联合体成员Characteristics是否等于0，即可判断是否已遍历所有的导入表。</p><div class="note note-info">            <p>其实可以将导入表的入口地址，解释为一个存储了DATA_IMPORT_DIRECTORY结构的数组成员。</p>          </div><h3 id="INT与IAT"><a href="#INT与IAT" class="headerlink" title="INT与IAT"></a>INT与IAT</h3><p>INT，即Import Name Table，直译为导入名称表。</p><p>IAT，即Import Address Table，直译为导入地址表。</p><p>DATA_IMPORT_DIRECTORY结构的OriginalFirstThunk指向INT，FirstThunk成员指向IAT。</p><p>需要注意的是，IAT表也可以通过OP头的DataDirectory数组来找到，它位于DataDirectory数组的第13个元素，即DataDirectory[12]。</p><p>INT表与IAT结构相同：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">DATA_THUNK_DATA</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>DWORD ForwarderString;      <span class="hljs-comment">// PBYTE</span><br>DWORD Function;             <span class="hljs-comment">// PDWORD</span><br>DWORD Ordinal;<br>DWORD AddressOfData;        <span class="hljs-comment">//RVA 指向_IMAGE_IMPORT_BY_NAME</span><br>&#125;;<br>&#125; DATA_THUNK_DATA, * PDATA_THUNK_DATA;<br></code></pre></td></tr></table></figure><p>看似复杂的结构，其实整个结构都是联合体，一般来说直接将其视为四字节整型DWORD即可。</p><p>当该值为0时，即到达末尾结束，因此可将INT和IAT都看作一个四字节整型数组，即DWORD[]。</p><h3 id="函数名称-or-函数序号"><a href="#函数名称-or-函数序号" class="headerlink" title="函数名称 or 函数序号"></a>函数名称 or 函数序号</h3><p>我们通过AddressOfData来获取数据。</p><p>AddressOfData为一个32bit的整型, 解析该值时需分两种情况：</p><ol><li>该值最高位为0，那么该值实际上是一个RVA，指向NAME结构，通过该结构的Name成员即可获取函数名称：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">DATA_IMPORT_BY_NAME</span> &#123;</span><br>WORD    Hint;       <span class="hljs-comment">//函数序号，无意义，一般无视该成员</span><br>BYTE    Name[<span class="hljs-number">1</span>];    <span class="hljs-comment">//函数名称，以0结尾</span><br>&#125; DATA_IMPORT_BY_NAME, * PDATA_IMPORT_BY_NAME;<br></code></pre></td></tr></table></figure><ol start="2"><li>该值最高位为1，那么该值是一个函数序号，去掉最高位后剩下的31位即为函数序号。</li></ol><h3 id="PE加载前后的不同之处"><a href="#PE加载前后的不同之处" class="headerlink" title="PE加载前后的不同之处"></a>PE加载前后的不同之处</h3><p>在PE文件加载前，INT和IAT两张表中存储的内容完全一样，都是函数的序号或函数名称。</p><p>而当PE文件加载完成之后，即OS已经将全部所需的导入函数找到后，IAT表中存储的不再是函数名称或序号，而是导入函数的绝对地址。</p><p>即AddressOfData存储的内容，已经变成一个绝对地址，该地址即导入函数的入口地址。</p><p>此时INT表与IAT互为对照，INT内存储名字，IAT内存储地址。</p><h2 id="编码实现打印导入表"><a href="#编码实现打印导入表" class="headerlink" title="编码实现打印导入表"></a>编码实现打印导入表</h2><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">work06</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//将指定文件加载到内存，并解析PE信息到PEFILE结构体</span><br>PEFILE peFile&#123; <span class="hljs-number">0</span> &#125;;<br>FILE* pFile = fopen(<span class="hljs-string">&quot;D:\\1.exe&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br><br><span class="hljs-type">int</span> fileLength = LoadFileToMemory(pFile, &amp;peFile);<br><span class="hljs-type">int</span> r = fclose(pFile);<br><br><span class="hljs-keyword">if</span> (peFile.h_pe == nullptr) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//获取导入表</span><br>PDATA_IMPORT_DIRECTORY pImportTable = nullptr;<br>GetImportTable(&amp;pImportTable, &amp;peFile);<br><br>PrintImportTable(pImportTable, &amp;peFile);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="打印导入表"><a href="#打印导入表" class="headerlink" title="打印导入表"></a>打印导入表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">PrintImportTable</span><span class="hljs-params">(PDATA_IMPORT_DIRECTORY pImportTable, lpPEFILE lpPeFile)</span> &#123;<br>DWORD imageBase = (DWORD)lpPeFile-&gt;h_dos;<br><br><span class="hljs-keyword">while</span> (pImportTable-&gt;Characteristics != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-type">char</span>* dllName = (<span class="hljs-type">char</span>*)Rva2Foa(pImportTable-&gt;Name, lpPeFile) + imageBase;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %s : \n OriginalFirstThunk ：0x%x \n FirstThunk : 0x%x \n&quot;</span>, <br>dllName, pImportTable-&gt;OriginalFirstThunk, pImportTable-&gt;FirstThunk);<br><br><span class="hljs-comment">//INT表</span><br>PDATA_THUNK_DATA pImportNameTable =<br>(PDATA_THUNK_DATA)(imageBase + Rva2Foa(pImportTable-&gt;OriginalFirstThunk, lpPeFile));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;INT:\n&quot;</span>);<br>PrintThunkData(pImportNameTable, lpPeFile);<br><span class="hljs-comment">//IAT表</span><br>PDATA_THUNK_DATA pImportAddressTable = <br>(PDATA_THUNK_DATA)(imageBase + Rva2Foa(pImportTable-&gt;FirstThunk, lpPeFile));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;IAT:\n&quot;</span>);<br>PrintThunkData(pImportNameTable, lpPeFile);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;**********&quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>pImportTable++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="打印IAT或INT表"><a href="#打印IAT或INT表" class="headerlink" title="打印IAT或INT表"></a>打印IAT或INT表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//此处假定PE文件未使用绑定导入表提前导入函数地址</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PrintThunkData</span><span class="hljs-params">(PDATA_THUNK_DATA thunkData, lpPEFILE lpPeFile)</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%8s\t%30s\t%10s\t%10s\t\n&quot;</span>, <span class="hljs-string">&quot;Adress:&quot;</span>, <span class="hljs-string">&quot;Name:&quot;</span>, <span class="hljs-string">&quot;Hint:&quot;</span>, <span class="hljs-string">&quot;OrderNo:&quot;</span>);<br><br>DWORD imageBase = (DWORD)lpPeFile-&gt;h_dos;<br>DWORD AddressOfData = thunkData-&gt;AddressOfData;<br><span class="hljs-keyword">while</span> (AddressOfData != <span class="hljs-literal">NULL</span>) &#123;<br>DWORD orderNo = AddressOfData &gt;&gt; <span class="hljs-number">31</span>;<br><br><span class="hljs-keyword">if</span> (orderNo == <span class="hljs-number">1</span>) &#123;<br>      orderNo = AddressOfData &amp; <span class="hljs-number">0x7FFFFFFF</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%8x\t%30s\t%10s\t%10d \n&quot;</span>, AddressOfData, <span class="hljs-string">&quot;Null&quot;</span>, <span class="hljs-string">&quot;Null&quot;</span>, orderNo);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>PDATA_IMPORT_BY_NAME name =<br>(PDATA_IMPORT_BY_NAME)(Rva2Foa(AddressOfData, lpPeFile) + imageBase);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%8x\t%30s\t%10d\t%10d \n&quot;</span>, AddressOfData, name-&gt;Name, name-&gt;Hint, orderNo);<br>&#125;<br><br>thunkData++;<br>AddressOfData = thunkData-&gt;AddressOfData;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>上善若水</category>
      
      <category>PE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>PE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PE结构(8)转移导出表</title>
    <link href="/blogs/2024050701250065136.html"/>
    <url>/blogs/2024050701250065136.html</url>
    
    <content type="html"><![CDATA[<p>转移导出表到自定义节是个有一点点挑战性的工作，但这确实是各种PE加密、解密的基础。</p><p>原因在于，对PE文件进行加密时，并不允许破坏PE本身的结构，否则会导致OS无法加载PE文件。因此一个常见做法，就是将PE中的各类表、表数据转移到加密者新增的一个节中，而后对其他节内的数据进行加密。</p><p>这样即可在不破坏PE数据结构的情况下，对用户数据进行加密操作。可以看到像是VMP这类加密工具，会在原文件中留下经典的<em>vmp</em>节表项，就是在做这个事情。</p><p>各类表的转移中，导出表算是个比较麻烦的家伙，想把它无损转移，大致上分为八个步骤：</p><ol><li>新增一个自定义节</li><li>将函数表（AddressOfFunctions）拷贝到新节中</li><li>将序号表（AddressOfNameOrdinals）拷贝到新节中</li><li>将名称表（AddressOfNames）拷贝到新节中</li><li>将名称表引用的字符串拷贝到新节中，修复名称表内的地址</li><li>将导出表的目录结构（DATA_EXPORT_DIRECTORY）拷贝到新节中</li><li>修复导出表目录结构，关联在 2、3、4 步中拷贝的数据</li><li>修复PE头，使数据目录页数组中保留我们新的目录地址（RVA）</li></ol><p>最后Dump存盘即可。</p><h2 id="完整代码实现"><a href="#完整代码实现" class="headerlink" title="完整代码实现"></a>完整代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PE.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PEStruct.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;InjectPE.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">work05</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//将指定文件加载到内存，并解析PE信息到PEFILE结构体</span><br>PEFILE peFile&#123; <span class="hljs-number">0</span> &#125;;<br>FILE* pFile = fopen(<span class="hljs-string">&quot;D:\\TestDLL.dll&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br><span class="hljs-comment">//此处的LoadFileToMemory方法做过特殊处理，会开辟额外的内存空间，方便后续追加节的操作</span><br><span class="hljs-type">int</span> fileLength = LoadFileToMemory(pFile, &amp;peFile);<br><span class="hljs-type">int</span> r = fclose(pFile);<br><br><span class="hljs-keyword">if</span> (peFile.h_pe == nullptr) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>DWORD bufferImageBase = (DWORD)peFile.h_dos;<br><br><span class="hljs-comment">//获取导出表</span><br>PDATA_EXPORT_DIRECTORY lpExportTable = nullptr;<br>GetExportTable(&amp;lpExportTable, &amp;peFile);<br><span class="hljs-keyword">if</span> (lpExportTable == nullptr) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//第一步，添加节，此处添加一个名为.crack，长度为4000字节的</span><br>lpPETable newTable = (lpPETable)AddSection(&amp;peFile, (<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;.crack&quot;</span>, <span class="hljs-number">0x1000</span>);<br><span class="hljs-keyword">if</span> (newTable == nullptr) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>DWORD index = bufferImageBase + newTable-&gt;PointerToRawData;<br><br><span class="hljs-comment">//第二步，转移函数表</span><br>DWORD functionTableFOA = Rva2Foa(lpExportTable-&gt;AddressOfFunctions, &amp;peFile);<br><span class="hljs-type">void</span>* functionTableAddress = (<span class="hljs-type">void</span>*)(bufferImageBase + functionTableFOA);<br>DWORD functionTableSize = <span class="hljs-keyword">sizeof</span>(DWORD) * lpExportTable-&gt;NumberOfFunctions;<br><span class="hljs-built_in">memcpy</span>((<span class="hljs-type">void</span>*)index, functionTableAddress, functionTableSize);<br>index += functionTableSize;<br><br><span class="hljs-comment">//第三步，转移序号表</span><br>DWORD orderTableFOA = Rva2Foa(lpExportTable-&gt;AddressOfNameOrdinals, &amp;peFile);<br><span class="hljs-type">void</span>* orderTableAddress = (<span class="hljs-type">void</span>*)(bufferImageBase + orderTableFOA);<br>DWORD orderTableSize = <span class="hljs-keyword">sizeof</span>(WORD) * lpExportTable-&gt;NumberOfNames;<br><span class="hljs-built_in">memcpy</span>((<span class="hljs-type">void</span>*)index, orderTableAddress, orderTableSize);<br>index += orderTableSize;<br><br><span class="hljs-comment">//第四步，转移名称表</span><br>DWORD nameTableFOA = Rva2Foa(lpExportTable-&gt;AddressOfNames, &amp;peFile);<br><span class="hljs-type">void</span>* nameTableAddress = (<span class="hljs-type">void</span>*)(bufferImageBase + nameTableFOA);<br>DWORD nameTableSize = <span class="hljs-keyword">sizeof</span>(DWORD) * lpExportTable-&gt;NumberOfNames;<br><span class="hljs-built_in">memcpy</span>((<span class="hljs-type">void</span>*)index, nameTableAddress, nameTableSize);<br><span class="hljs-comment">//保留该地址，之后修复名称表用得到</span><br>DWORD* newNameTableItems = (DWORD*)index;<br>index += nameTableSize;<br><br><span class="hljs-comment">//第五步，修复名称表</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lpExportTable-&gt;NumberOfNames; i++) &#123;<br>DWORD nameRVA = ((DWORD*)nameTableAddress)[i];<br>DWORD nameFOA = Rva2Foa(nameRVA, &amp;peFile);<br><span class="hljs-type">char</span>* nameItem = (<span class="hljs-type">char</span>*)(nameFOA + bufferImageBase);<br><span class="hljs-type">int</span> nameSize = <span class="hljs-built_in">strlen</span>(nameItem);<br><span class="hljs-comment">//勿要忽略\0</span><br><span class="hljs-built_in">memcpy</span>((<span class="hljs-type">void</span>*)index, nameItem, nameSize + <span class="hljs-number">1</span>);<br><span class="hljs-comment">//新名称表字符串内存地址更新</span><br>newNameTableItems[i] = (DWORD)index;<br>index += nameSize + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//第六步，拷贝导出表目录页</span><br>DWORD exportDirectorySize = <span class="hljs-keyword">sizeof</span>(DATA_EXPORT_DIRECTORY);<br>PDATA_EXPORT_DIRECTORY lpNewExportTable = (PDATA_EXPORT_DIRECTORY)index;<br><span class="hljs-built_in">memcpy</span>((<span class="hljs-type">void</span>*)index, lpExportTable, exportDirectorySize);<br>index += exportDirectorySize;<br><br><span class="hljs-comment">//第七步，修复导出表目录页</span><br>lpNewExportTable-&gt;AddressOfFunctions = Foa2Rva(functionTableFOA, &amp;peFile);<br>lpNewExportTable-&gt;AddressOfNameOrdinals = Foa2Rva(orderTableFOA, &amp;peFile);<br>lpNewExportTable-&gt;AddressOfNames = Foa2Rva(nameTableFOA, &amp;peFile);<br><br><span class="hljs-comment">//第八步，修复PE头</span><br>DWORD NewExportTableFOA = (DWORD)lpNewExportTable - bufferImageBase;<br>DWORD NewExportTableRVA = Foa2Rva(NewExportTableFOA, &amp;peFile);<br>lpPe_DATA_DIRECTORY directory = &amp;peFile.h_op-&gt;DataDirectory[<span class="hljs-number">0</span>];<br>directory-&gt;VirtualAddress = NewExportTableRVA;<br><br>pFile = fopen(<span class="hljs-string">&quot;D:\\TestDLL2.dll&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>);<br>DumpFileBufferToFile(pFile, &amp;peFile);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>上善若水</category>
      
      <category>PE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>PE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PE结构(7)修复重定位表</title>
    <link href="/blogs/20240506163100318.html"/>
    <url>/blogs/20240506163100318.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本篇的理论概述已经在其他文章中给出，此处直接给代码实现。</p>          </div><p><a href="https://dubhehub.github.io/blogs/2024050500180037226.html">PE结构(6)重定位表</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="主入口函数"><a href="#主入口函数" class="headerlink" title="主入口函数"></a>主入口函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//将指定文件加载到内存，并解析PE信息到PEFILE结构体</span><br>PEFILE peFile&#123; <span class="hljs-number">0</span> &#125;;<br>FILE* pFile = fopen(<span class="hljs-string">&quot;D:\\TestDLL.dll&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br><span class="hljs-type">int</span> fileLength = LoadFileToMemory(pFile, &amp;peFile);<br>fclose(pFile);<br><br><span class="hljs-comment">//将ImageBase修改掉</span><br><span class="hljs-keyword">if</span> (peFile.h_op == nullptr) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>DWORD oldImageBase = peFile.h_op-&gt;ImageBase;<br>peFile.h_op-&gt;ImageBase = <span class="hljs-number">0x20000000</span>;<br><br><span class="hljs-comment">//按重定位表修复</span><br>PDATA_RELOCATION_DIRECTORY pRelocationTable = nullptr;<br>GetRelocationTable(&amp;pRelocationTable, &amp;peFile);<br>FixedRelocationTable(pRelocationTable, &amp;peFile, oldImageBase);<br><br><span class="hljs-comment">//dump为新文件</span><br><span class="hljs-comment">//根据内存映像dump到磁盘</span><br>pFile = fopen(<span class="hljs-string">&quot;D:\\TestDLL2.dll&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>);<br>DumpFileBufferToFile(pFile, &amp;peFile);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修复函数"><a href="#修复函数" class="headerlink" title="修复函数"></a>修复函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//修复重定位表数据</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FixedRelocationTable</span><span class="hljs-params">(PDATA_RELOCATION_DIRECTORY table, lpPEFILE lpPEFile, DWORD oldImageBase)</span> &#123;<br>DWORD imageBaseOffset = lpPEFile-&gt;h_op-&gt;ImageBase - oldImageBase;<br>DWORD fileStart = (DWORD)lpPEFile-&gt;h_dos;<br><br><span class="hljs-keyword">while</span> (table-&gt;VirtualAddress != <span class="hljs-number">0</span> &amp;&amp; table-&gt;SizeOfBlock != <span class="hljs-number">0</span>) &#123;<br>DWORD virtualAddress = table-&gt;VirtualAddress;<br>DWORD offsetNum = (table-&gt;SizeOfBlock - <span class="hljs-number">8</span>) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; offsetNum; i++) &#123;<br>WORD offset = table-&gt;TypeOffset[i];<br>BYTE high4bit = offset &gt;&gt; <span class="hljs-number">12</span>;<br>WORD low12bit = offset &amp; <span class="hljs-number">0x0FFF</span>;<br><br><span class="hljs-keyword">if</span> (high4bit != <span class="hljs-number">3</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br>DWORD targetFOA = Rva2Foa(virtualAddress + low12bit, lpPEFile);<br>DWORD* opNumber = (DWORD*)(fileStart + targetFOA);<br>*opNumber = *opNumber + imageBaseOffset;<br>&#125;<br>table = (PDATA_RELOCATION_DIRECTORY)((DWORD)table + table-&gt;SizeOfBlock);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dump文件buffer函数"><a href="#dump文件buffer函数" class="headerlink" title="dump文件buffer函数"></a>dump文件buffer函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">DumpFileBufferToFile</span><span class="hljs-params">(FILE* pFile, lpPEFILE peFile)</span> &#123;<br>fseek(pFile, <span class="hljs-number">0</span>, SEEK_SET);<br>DWORD size = peFile-&gt;h_op-&gt;SizeOfImage;<br>DWORD bufferImageBase = (DWORD)peFile-&gt;h_dos;<br><br><span class="hljs-comment">//PE属性</span><br>lpPEHDOS lpHdos = peFile-&gt;h_dos;<br><span class="hljs-keyword">if</span> (lpHdos == nullptr) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>lpPEHPE lpHpe = peFile-&gt;h_pe;<br><span class="hljs-keyword">if</span> (lpHpe == nullptr) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>lpPEHOPTIONAL lpHop = peFile-&gt;h_op;<br><span class="hljs-keyword">if</span> (lpHop == nullptr) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>lpPETable lpTable = peFile-&gt;pet;<br><span class="hljs-keyword">if</span> (lpTable == nullptr) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//拷贝PE头</span><br>DWORD sizeOfHeader = lpHop-&gt;SizeOfHeader;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sizeOfHeader; i++) &#123;<br>BYTE byte = *((LPBYTE)bufferImageBase + i);<br>fputc(byte, pFile);<br>&#125;<br><br><span class="hljs-comment">//遍历节表，拷贝每一节</span><br>WORD numberOfSections = lpHpe-&gt;NumberOfSections;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num = <span class="hljs-number">0</span>; num &lt; numberOfSections; num++) &#123;<br>lpPETable t = (lpTable + num);<br>DWORD pointerToRawData = t-&gt;PointerToRawData;<br>DWORD sizeOfRawData = t-&gt;SizeOfRawData;<br><br>fseek(pFile, pointerToRawData, SEEK_SET);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sizeOfRawData; i++) &#123;<br>BYTE byte = *((LPBYTE)bufferImageBase + pointerToRawData + i);<br>fputc(byte, pFile);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试修复效果"><a href="#测试修复效果" class="headerlink" title="测试修复效果"></a>测试修复效果</h2><h3 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">float</span> <span class="hljs-params">(*MulFunc)</span><span class="hljs-params">(<span class="hljs-type">float</span>, <span class="hljs-type">float</span>)</span>;<br>MulFunc mul = nullptr;<br><br>HMODULE hModule = LoadLibraryA(<span class="hljs-string">&quot;D:\\TestDLL2.dll&quot;</span>);<br><span class="hljs-keyword">if</span> (hModule == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br>mul = (MulFunc)GetProcAddress(hModule, <span class="hljs-string">&quot;mul&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mul result : %.2f&quot;</span>, mul(<span class="hljs-number">5.0f</span>, <span class="hljs-number">6.0f</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h3><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/20240506163100318/1.png"></p>]]></content>
    
    
    <categories>
      
      <category>上善若水</category>
      
      <category>PE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>PE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PE结构(6)重定位表</title>
    <link href="/blogs/2024050500180037226.html"/>
    <url>/blogs/2024050500180037226.html</url>
    
    <content type="html"><![CDATA[<h2 id="所在位置"><a href="#所在位置" class="headerlink" title="所在位置"></a>所在位置</h2><p>重定位表处于OP头的数据目录页数组的第六张表，即 PE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBERSOF_DIRECTORY_ENTRY]; 数组的第五个元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PE_DATA_DIRECTORY</span> &#123;</span><br>DWORD VirtualAddress;<br>DWORD Size;<br>&#125;PE_DATA_DIRECTORY, *lpPe_DATA_DIRECTORY;<br></code></pre></td></tr></table></figure><p>该目录页的<em>VirtualAddress</em>字段指向了重定位表所在RVA。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>重定位表结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">DATA_RELOCATION_DIRECTORY</span> &#123;</span><br>DWORD VirtualAddress;<br>DWORD SizeOfBlock;<br><span class="hljs-comment">//原则上该成员不属于此结构体</span><br>WORD TypeOffset[<span class="hljs-number">1</span>];<br>&#125;DATA_RELOCATION_DIRECTORY, * PDATA_RELOCATION_DIRECTORY;<br></code></pre></td></tr></table></figure><p>由于重定位表在一个PE文件上不止存在一张，事实上存在多张。这多张重定位表之间的间隔并不固定，所幸有<em>SizeOfBlock</em>字段用于确认某张重定位表占用空间的大小。</p><p>假设第一张重定位表处于地址A，则A + SizeOfBlock 即为第二张重定位表所在地址。</p><p>若一张重定位表的 VirtualAddress 和 SizeOfBlock 均为0，则代表已没有新的重定位表。</p><p>基于此原理，遍历所有重定位表具有可行性。</p><h2 id="代码演示遍历重定位表"><a href="#代码演示遍历重定位表" class="headerlink" title="代码演示遍历重定位表"></a>代码演示遍历重定位表</h2><p>主函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main3</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//将指定文件加载到内存，并解析PE信息到PEFILE结构体</span><br>PEFILE peFile&#123; <span class="hljs-number">0</span> &#125;;<br>FILE* pFile = fopen(<span class="hljs-string">&quot;D:\\TestDLL.dll&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br><span class="hljs-type">int</span> fileLength = LoadFileToMemory(pFile, &amp;peFile);<br>fclose(pFile);<br><br><span class="hljs-keyword">if</span> (peFile.h_pe == nullptr) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//获取重定位表</span><br>PDATA_RELOCATION_DIRECTORY pRelocationTable = nullptr;<br>GetRelocationTable(&amp;pRelocationTable, &amp;peFile);<br><span class="hljs-keyword">if</span> (pRelocationTable == nullptr) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>PrintRelocationTable(pRelocationTable, &amp;peFile);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//打印重定位表内容</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PrintRelocationTable</span><span class="hljs-params">(PDATA_RELOCATION_DIRECTORY pRelocationTable, lpPEFILE lpPefile)</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;输出重定位表内容.&quot;</span>);<br>DWORD virtualAddress = pRelocationTable-&gt;VirtualAddress;<br>DWORD sizeOfBlock = pRelocationTable-&gt;SizeOfBlock;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (virtualAddress != <span class="hljs-number">0</span> &amp;&amp; sizeOfBlock != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前第 %d 张重定位表内容：\n&quot;</span>, i);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;大表地址:0x%x \n&quot;</span>, virtualAddress);<br><span class="hljs-type">int</span> elementsCount = (sizeOfBlock - <span class="hljs-number">8</span>) / <span class="hljs-number">2</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;小表项数量:%d \n&quot;</span>, elementsCount);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; elementsCount; i++) &#123;<br>WORD element = pRelocationTable-&gt;TypeOffset[i];<br>BYTE high4 = element &gt;&gt; <span class="hljs-number">12</span>;<br>WORD low12 = element &amp; <span class="hljs-number">0x0FFF</span>;<br>DWORD rva = virtualAddress + low12;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前第%d项, 偏移:0x%x, 标记:0x%x, RVA:0x%x, FOA:0x%x \n&quot;</span>,<br>i + <span class="hljs-number">1</span>, low12, high4, rva, Rva2Foa(rva, lpPefile));<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;****************************************\n&quot;</span>);<br>pRelocationTable = (PDATA_RELOCATION_DIRECTORY)((DWORD)pRelocationTable + sizeOfBlock);<br>virtualAddress = pRelocationTable-&gt;VirtualAddress;<br>sizeOfBlock = pRelocationTable-&gt;SizeOfBlock;<br>i++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重定位表作用"><a href="#重定位表作用" class="headerlink" title="重定位表作用"></a>重定位表作用</h2><p>代码在编译时，虽然会尽可能使用相对地址（RVA）作为汇编硬编码的操作数，但是在使用某些资源（如全局变量）时，会将PE文件的ImageBase与该变量的RVA相加后直接硬编码在程序中。</p><p>若程序每次运行时的ImageBase永远不发生变更，那这样的编码方式并不会出现问题。</p><p>可实际上程序运行，尤其是DLL这类模块型文件被装载时，由于ImageBase有冲突，经常要发生临时变更ImageBase的情景。此时程序文件中硬编码的语句，已无法寻址获取到原内存空间上的数据，这类语句执行就会发生问题。</p><div class="note note-danger">            <p>此时我们的重定位表就要闪亮登场了！</p>          </div><h3 id="记录所有变更"><a href="#记录所有变更" class="headerlink" title="记录所有变更"></a>记录所有变更</h3><p>最朴素的一种想法就是，如果在编译时，记录下所有“写死”的地方，当ImageBase发生变更时，就对这些记录的地址进行修正，问题不就解决了嘛？</p><p>因为ImageBase无论怎么变更，与原ImageBase相比较时，总能算得一个offset；我们预先记录了硬编码的操作数所在的地址，当ImageBase发生变更时，就对这些地址上的数加上这个offset。这就能确保程序仍然可以访问正确的内存地址。</p><p>重定位表所做的，正是这么一回事。</p><h3 id="结构解析"><a href="#结构解析" class="headerlink" title="结构解析"></a>结构解析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">DATA_RELOCATION_DIRECTORY</span> &#123;</span><br>DWORD VirtualAddress;<br>DWORD SizeOfBlock;<br><span class="hljs-comment">//原则上该成员不属于此结构体</span><br>WORD TypeOffset[<span class="hljs-number">1</span>];<br>&#125;DATA_RELOCATION_DIRECTORY, * PDATA_RELOCATION_DIRECTORY;<br></code></pre></td></tr></table></figure><p>一张重定位表中，VirtualAddress 记录了一个页地址（某内存页的起始地址），从SizeOfBlock之后的内存中，每两字节记录一个偏移地址。</p><div class="note note-info">            <p>聪明如我的读者，应该已经想到如何计算有多少个偏移地址了吧？<br>_DATA_RELOCATION_DIRECTORY 结构体是按一字节内存对齐的，这意味着所有数据是紧凑排列的。<br>用 (SizeOfBlock - 8) &#x2F; 2 的公式，即可求得所有偏移量的数量了，有了数量即可遍历该结构体。</p>          </div><p>用页地址 + 偏移地址的方式，即可找到某个需要修改的操作数所在的地址，32位系统中将该值按四字节读取后加上需要追加的offset即可完成修复工作。</p><h3 id="然而还有一个坑"><a href="#然而还有一个坑" class="headerlink" title="然而还有一个坑"></a>然而还有一个坑</h3><p>或许你对内存结构颇有研究，会提出一个问题：“一页内存只有4096字节，理论上偏移量只需要12位bit即可存储，那么两字节存储是不是浪费了4bit的数据宽度呢？”</p><p>可惜Microsoft技高一筹，早就想到了这个问题。</p><p>因此每个偏移量的16位bit上，高4位被用于标记位，低12位才是偏移量。</p><p><strong>只有高4位bit的值等于3时，才说明该地址需要被修复。</strong></p><p>这意味着如果你想模拟OS修复重定位表的话，必须分开处理每个<em>TypeOffset</em>的高4bit与低12bit。</p><p>我将在之后的文章中给出这么做的代码实现。</p>]]></content>
    
    
    <categories>
      
      <category>上善若水</category>
      
      <category>PE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>PE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PE结构(5)新增节</title>
    <link href="/blogs/2024050415400062615.html"/>
    <url>/blogs/2024050415400062615.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一步，遍历节表"><a href="#第一步，遍历节表" class="headerlink" title="第一步，遍历节表"></a>第一步，遍历节表</h1><p>首先应当遍历节表，找到最后一节。</p><p>尝试在该节后找到一段连续的40字节空间，因为节表中每一项的长度是固定的40字节。</p><p>找到这块空间，便于我们操作。</p><p>寻找连续空间的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C">DWORD <span class="hljs-title function_">FindEmptyAddress</span><span class="hljs-params">(<span class="hljs-type">void</span>* start, <span class="hljs-type">int</span> maxSize, <span class="hljs-type">int</span> codeLen)</span> &#123;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt;= maxSize - codeLen) &#123;<br><span class="hljs-type">char</span> *current = (<span class="hljs-type">char</span>*)start + i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; codeLen; j++) &#123;<br><span class="hljs-keyword">if</span> (current[j] != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>count++;<br>&#125;<br><span class="hljs-keyword">if</span> (count == codeLen) &#123;<br><span class="hljs-keyword">return</span> (DWORD)current;<br>&#125;<br>i += count + <span class="hljs-number">1</span>;<br>count = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>找到连续的空间，确定插入新节的位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> <span class="hljs-title function_">AddSection</span><span class="hljs-params">(lpPEFILE peFile, <span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> length)</span> &#123;<br>lpPEHPE peHeader = peFile-&gt;h_pe;<br>lpPETable table = peFile-&gt;pet;<br><br><span class="hljs-type">int</span> sections = peHeader-&gt;NumberOfSections;<br><br><span class="hljs-comment">//提前确定了位置，直接来到我们想插入新表的位置</span><br>lpPETable newTable = table + sections;<br><br><span class="hljs-comment">//确定这个位置是40字节的连续空闲空间</span><br>DWORD injectEntry = FindEmptyAddress(newTable, <span class="hljs-number">0x28</span>, <span class="hljs-number">0x28</span>);<br><br><span class="hljs-keyword">if</span> (injectEntry == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="第二步，复制节"><a href="#第二步，复制节" class="headerlink" title="第二步，复制节"></a>第二步，复制节</h1><p>先将最后一节复制到我们找到的这40字节空间中。</p><p>这样我们只需要在原节表的结构上修改即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//将原节表的40字节内容复制到新空间</span><br><span class="hljs-built_in">memcpy</span>(newTable, table + sections - <span class="hljs-number">1</span>, <span class="hljs-number">0x28</span>);<br><span class="hljs-comment">//给新节表的名字赋个值</span><br><span class="hljs-built_in">memcpy</span>(newTable-&gt;name, name, <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><h1 id="第三步，修复节表"><a href="#第三步，修复节表" class="headerlink" title="第三步，修复节表"></a>第三步，修复节表</h1><p>新节表复制好了，但是其属性内容不太正常，我们需要修复一下（注意，此处要考虑内存对齐问题）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//文件内偏移，即FOA，直接加上老节表的Size即可</span><br>newTable-&gt;PointerToRawData += newTable-&gt;SizeOfRawData;<br><span class="hljs-comment">//内存内偏移，即RVA，直接加上老节表的Size即可</span><br>newTable-&gt;VirtualAddress += newTable-&gt;VirtualSize;<br><span class="hljs-comment">//设置本节在文件中长度，此处给了一个固定值</span><br>newTable-&gt;SizeOfRawData = length;<br><span class="hljs-comment">//同上，设置该节在内存中长度</span><br>newTable-&gt;VirtualSize = length;<br><br><span class="hljs-comment">//节表RVA，按内存对齐字段修复</span><br>DWORD sectionAlignment = peFile-&gt;h_op-&gt;SectionAlignment;<br>DWORD alignMod = newTable-&gt;VirtualAddress % sectionAlignment;<br><span class="hljs-keyword">if</span> (alignMod != <span class="hljs-number">0</span>) &#123;<br>newTable-&gt;VirtualAddress += (sectionAlignment - alignMod);<br>&#125;<br><br><span class="hljs-comment">//节表FOA，按文件对齐字段修复</span><br>DWORD fileAlignment = peFile-&gt;h_op-&gt;FileAlignment;<br>alignMod = newTable-&gt;PointerToRawData % fileAlignment;<br><span class="hljs-keyword">if</span> (alignMod != <span class="hljs-number">0</span>) &#123;<br>newTable-&gt;PointerToRawData += (fileAlignment - alignMod);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第四步，修复PE头"><a href="#第四步，修复PE头" class="headerlink" title="第四步，修复PE头"></a>第四步，修复PE头</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//镜像的大小加上新增节的长度</span><br>peFile-&gt;h_op-&gt;SizeOfImage += length;<br><span class="hljs-comment">//PE头内增加节表项数量</span><br>peHeader-&gt;NumberOfSections += <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h1 id="第五步，初始化新节"><a href="#第五步，初始化新节" class="headerlink" title="第五步，初始化新节"></a>第五步，初始化新节</h1><p>此处我就全部用0填充了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">DWORD imageBase = (DWORD)peFile-&gt;h_dos;<br><span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)(imageBase + newTable-&gt;PointerToRawData), <span class="hljs-number">0</span>, newTable-&gt;SizeOfRawData);<br></code></pre></td></tr></table></figure><h1 id="完整函数"><a href="#完整函数" class="headerlink" title="完整函数"></a>完整函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> <span class="hljs-title function_">AddSection</span><span class="hljs-params">(lpPEFILE peFile, <span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> length)</span> &#123;<br>lpPEHPE peHeader = peFile-&gt;h_pe;<br>lpPETable table = peFile-&gt;pet;<br><br><span class="hljs-type">int</span> sections = peHeader-&gt;NumberOfSections;<br><span class="hljs-comment">//step1 寻找新空间</span><br>lpPETable newTable = table + sections;<br>DWORD injectEntry = FindEmptyAddress(newTable, <span class="hljs-number">0x28</span>, <span class="hljs-number">0x28</span>);<br><br><span class="hljs-keyword">if</span> (injectEntry == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//step2 拷贝节表</span><br><span class="hljs-built_in">memcpy</span>(newTable, table + sections - <span class="hljs-number">1</span>, <span class="hljs-number">0x28</span>);<br><span class="hljs-built_in">memcpy</span>(newTable-&gt;name, name, <span class="hljs-number">8</span>);<br><br><span class="hljs-comment">//step3 修复节表属性</span><br>newTable-&gt;PointerToRawData += newTable-&gt;SizeOfRawData;<br>newTable-&gt;VirtualAddress += newTable-&gt;VirtualSize;<br>newTable-&gt;SizeOfRawData = length;<br>newTable-&gt;VirtualSize = length;<br><br><span class="hljs-comment">//内存对齐</span><br>DWORD sectionAlignment = peFile-&gt;h_op-&gt;SectionAlignment;<br>DWORD alignMod = newTable-&gt;VirtualAddress % sectionAlignment;<br><span class="hljs-keyword">if</span> (alignMod != <span class="hljs-number">0</span>) &#123;<br>newTable-&gt;VirtualAddress += (sectionAlignment - alignMod);<br>&#125;<br><span class="hljs-comment">//文件对齐</span><br>DWORD fileAlignment = peFile-&gt;h_op-&gt;FileAlignment;<br>alignMod = newTable-&gt;PointerToRawData % fileAlignment;<br><span class="hljs-keyword">if</span> (alignMod != <span class="hljs-number">0</span>) &#123;<br>newTable-&gt;PointerToRawData += (fileAlignment - alignMod);<br>&#125;<br><br><span class="hljs-comment">//step4 修复PE头</span><br>peFile-&gt;h_op-&gt;SizeOfImage += length;<br>peHeader-&gt;NumberOfSections += <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//step5 初始化节内空间</span><br>DWORD imageBase = (DWORD)peFile-&gt;h_dos;<br><span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)(imageBase + newTable-&gt;PointerToRawData), <span class="hljs-number">0</span>, newTable-&gt;SizeOfRawData);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>上善若水</category>
      
      <category>PE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>PE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PE结构(番外)RVA与FOA</title>
    <link href="/blogs/2024050116220046929.html"/>
    <url>/blogs/2024050116220046929.html</url>
    
    <content type="html"><![CDATA[<h1 id="RVA与FOA的概念"><a href="#RVA与FOA的概念" class="headerlink" title="RVA与FOA的概念"></a>RVA与FOA的概念</h1><h2 id="RVA"><a href="#RVA" class="headerlink" title="RVA"></a>RVA</h2><p>所谓RVA，即Relative virtual address，直白翻译的话就是“相对虚拟地址”。</p><p>先了解下为什么需要这个东西吧。</p><p>假设一段程序，其内存起始地址是0x4001000，当前运行的语句则位于0x4002000，那么该语句相对于起始地址来说，偏移了多少字节呢？</p><p>0x4002000 - 0x4001000 &#x3D; 0x1000</p><p>即偏移了4096字节，对吧？</p><p>我们将这个<strong>0x1000</strong>，称之为当前运行语句相对于内存起始地址的<strong>RVA</strong>。</p><p>为什么要有这个概念呢？</p><p>因为实际的应用中，由于内存起始地址不是一尘不变的，事实上出于安全性考虑，现代操作系统会给程序分配随机的起始内存地址。这就导致如果我们想要记录某个语句在内存中的位置，那么由于其内存地址总是在发生变化而变得不可靠。</p><p>仍以上面的例子来说，假如内存起始地址由0x4001000变更为0x4902300，那么我们之前记录的0x4002000这个地址就不再有效了。</p><p>但是无论起始地址如何变动，运行语句相对于起始地址的偏移量是不变的，对不对？也就是说，RVA是不会变动的。</p><p>那么我们只需要假设程序的内存起始地址为0x00000000，然后记录每个语句相对于0的RVA，之后无论起始地址如何变动，只需要对每个RVA加上这个起始地址，就可以保证程序正常运行了。</p><div class="note note-info">            <p>这个起始地址，一般就称之为ImageBase，程序运行的入口地址（OEP）则是一个RVA。<br>真实调度时，需要将OEP加上ImageBase，来确定程序的入口。</p>          </div><h2 id="FOA"><a href="#FOA" class="headerlink" title="FOA"></a>FOA</h2><p>其实了解了RVA的概念之后，FOA就很好了解了。</p><p>RVA是某个语句相对于ImageBase的偏移量，这是内存中的故事。</p><p>程序在装载到内存之前，是存放在文件中的，那么某个语句相对于文件开始位置的偏移量，就称之为FOA。</p><h2 id="两者间的转换逻辑"><a href="#两者间的转换逻辑" class="headerlink" title="两者间的转换逻辑"></a>两者间的转换逻辑</h2><p>当我们已知某个语句、某个程序段、又或是某个数据目录页的RVA，想要找到它在文件中的位置时，应该怎么做呢？</p><h3 id="情况一，RVA处于PE头部"><a href="#情况一，RVA处于PE头部" class="headerlink" title="情况一，RVA处于PE头部"></a>情况一，RVA处于PE头部</h3><p>无论这个RVA处于DOS头范围内、PE头范围内、OP头范围内、或是节表范围内，<strong>它相对于ImageBase的偏移量和它相对于文件开始位置的偏移量就一定是相等的。</strong></p><p>我们可以使用OP头内的<em>SizeOfHeader</em>来做判断，如果RVA小于<em>SizeOfHeader</em>，那么它其实就是FOA了。</p><h3 id="情况二，RVA处于某个节内"><a href="#情况二，RVA处于某个节内" class="headerlink" title="情况二，RVA处于某个节内"></a>情况二，RVA处于某个节内</h3><p>这种情况才是常规情况，如果RVA处于程序的某个节中，那么我们就不能直接使用它来作为FOA了。</p><p>因为节内的数据，在装入内存中时，存在拉伸过程。其相对于文件开始位置的偏移已经不再可靠了。</p><p>我们应当先找到RVA处于哪个节中，即遍历所有节表，判断RVA是否大于该节的起始地址，并且小于该节的起始地址+该节的长度。</p><p>找到RVA位于的节后，就可以用RVA减去该节的起始地址，得到相对于该节的偏移量。</p><p>再通过该节在文件中的起始位置，加上这个偏移量，得到这段程序在文件中的实际位置。</p><div class="note note-info">            <p>在节表中，每个节的目录描述了该节的属性。<br>节的起始地址（RVA）：VirtualAddress<br>该节的长度：PhysicalAddress&#x2F;VirtualSize<br>节的起始地址（FOA）：PointerToRawData</p>          </div><h1 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//将RVA转换为FOA</span><br>DWORD <span class="hljs-title function_">Rva2Foa</span><span class="hljs-params">(DWORD rva, lpPEFILE lpPEFile)</span> &#123;<br><span class="hljs-keyword">if</span> (rva &lt; lpPEFile-&gt;h_op-&gt;SizeOfHeader) &#123;<br><span class="hljs-keyword">return</span> rva;<br>&#125;<br><br>lpPETable tableBase = lpPEFile-&gt;pet;<br>lpPEHPE peHeader = lpPEFile-&gt;h_pe;<br>DWORD tableNum = peHeader-&gt;NumberOfSections;<br><br><span class="hljs-keyword">for</span> (DWORD num = <span class="hljs-number">0</span>; num &lt; tableNum; num++) &#123;<br>PETable table = tableBase[num];<br><span class="hljs-comment">//rva处于当前节内</span><br><span class="hljs-keyword">if</span> (rva &gt;= table.VirtualAddress &amp;&amp; rva &lt;= table.VirtualAddress + table.VirtualSize) &#123;<br>DWORD offset = rva - table.VirtualAddress;<br>DWORD foa = offset + table.PointerToRawData;<br><span class="hljs-keyword">return</span> foa;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//将FOA转换为RVA</span><br>DWORD <span class="hljs-title function_">Foa2Rva</span><span class="hljs-params">(DWORD foa, lpPEFILE lpPEFile)</span> &#123;<br><span class="hljs-keyword">if</span> (foa &lt; lpPEFile-&gt;h_op-&gt;SizeOfHeader) &#123;<br><span class="hljs-keyword">return</span> foa;<br>&#125;<br><br>lpPETable tableBase = lpPEFile-&gt;pet;<br>lpPEHPE peHeader = lpPEFile-&gt;h_pe;<br>DWORD tableNum = peHeader-&gt;NumberOfSections;<br><br><span class="hljs-keyword">for</span> (DWORD num = <span class="hljs-number">0</span>; num &lt; tableNum; num++) &#123;<br>PETable table = tableBase[num];<br><span class="hljs-keyword">if</span> (foa &gt; table.PointerToRawData &amp;&amp; foa &lt;= table.PointerToRawData + table.SizeOfRawData) &#123;<br>DWORD offset = foa - table.PointerToRawData;<br>DWORD rva = offset + table.VirtualAddress;<br><span class="hljs-keyword">return</span> rva;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>上善若水</category>
      
      <category>PE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>PE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PE结构(4)导出表</title>
    <link href="/blogs/2024043014020040528.html"/>
    <url>/blogs/2024043014020040528.html</url>
    
    <content type="html"><![CDATA[<h1 id="导出表概览"><a href="#导出表概览" class="headerlink" title="导出表概览"></a>导出表概览</h1><h2 id="所在位置"><a href="#所在位置" class="headerlink" title="所在位置"></a>所在位置</h2><p>首先我们观察PE结构的OP头结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PE_HEADERS_OPTIONAL</span> &#123;</span><br>...<br>PE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBERSOF_DIRECTORY_ENTRY];<br>&#125;PEHOPTIONAL, *lpPEHOPTIONAL;<br></code></pre></td></tr></table></figure><p>在OP头结构的最后一个结构体数组中，存放所有数据目录页。<strong>IMAGE_NUMBERSOF_DIRECTORY_ENTRY</strong>的值固定为15。</p><p>数据目录页结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PE_DATA_DIRECTORY</span> &#123;</span><br>DWORD VirtualAddress;<br>DWORD Size;<br>&#125;PE_DATA_DIRECTORY, *lpPe_DATA_DIRECTORY;<br></code></pre></td></tr></table></figure><p>其中，VirtualAddress是一个RVA, Size成员则基本没有意义。</p><div class="note note-info">            <p>RVA，即在虚拟内存中的相对地址，或者说是基于Imagebase的内存偏移量。<br>与之对应的概念是FOA，即基于文件起始地址的偏移量。<br>RVA与FOA之间存在转换关系。<br><a href="https://dubhehub.github.io/blogs/2024050116220046929.html">PE结构(番外)RVA与FOA</a></p>          </div><p>通过VirtualAddress我们可以找到指定的数据目录页所指向的数据表位于文件或内存中的具体位置。</p><p>导出表的数据目录页，即数组<em>DataDirectory</em>的第一个元素，即*DataDirectory[0]*。</p><p>将该数据目录页的VirtualAddress成员读取，转换为FOA，则可以定位导出表在文件中的位置。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>导出表的数据结构如下（内存1字节对齐）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">DATA_EXPORT_DIRECTORY</span> &#123;</span><br>DWORD   Characteristics;<br>DWORD   TimeDateStamp;<br>WORD    MajorVersion;<br>WORD    MinorVersion;<br>DWORD   Name;<br>DWORD   Base;<span class="hljs-comment">//导出函数的最小序号</span><br>DWORD   NumberOfFunctions;<span class="hljs-comment">//导出函数个数，不准确。计算公式：最大序号 - 最小序号 + 1</span><br>DWORD   NumberOfNames;<br>DWORD   AddressOfFunctions;     <span class="hljs-comment">// RVA from base of image</span><br>DWORD   AddressOfNames;         <span class="hljs-comment">// RVA from base of image</span><br>DWORD   AddressOfNameOrdinals;  <span class="hljs-comment">// RVA from base of image</span><br>&#125; DATA_EXPORT_DIRECTORY, * PDATA_EXPORT_DIRECTORY;<br></code></pre></td></tr></table></figure><p>其中较为重要的当属:</p><ol><li>AddressOfFunctions : 函数表，存储导出函数地址(RVA)，即四字节整数数组：DWORD[]</li><li>AddressOfNames : 名称表，存储导出函数名字的地址(RVA)，即四字节整数数组：DWORD[]</li><li>AddressOfNameOrdinals : 序号表，存储导出函数序号（RVA），即两字节整数数组：WORD[]</li></ol><div class="note note-danger">            <p>需要注意的是，序号表中存储的并不是真正的导出序号。<br>而是 导出序号 - Base 的值。即每个函数的序号，相对于最小序号的偏移量。<br>我理解这是一种防溢出的手段，毕竟序号表是两字节整形数组，能表达的序号长度有限。<br>而实际导出函数，也不太可能一个文件导出几十万个函数来吧，所以存储偏移量就足够了。</p>          </div><h2 id="获取导出函数的逻辑"><a href="#获取导出函数的逻辑" class="headerlink" title="获取导出函数的逻辑"></a>获取导出函数的逻辑</h2><h3 id="已知函数的名称"><a href="#已知函数的名称" class="headerlink" title="已知函数的名称"></a>已知函数的名称</h3><p>只有以名称导出的函数，才会存在于<em>AddressOfNames</em>名称表中。</p><p>首先遍历名称表，获取指向名称的指针，而后比对名称是否一致。若一致，则从序号表中获取其序号，然后通过函数表获取函数地址。</p><p>伪代码逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] NameTable;<span class="hljs-comment">//名称表</span><br>Short[] OrderTable;<span class="hljs-comment">//序号表</span><br>Integer[] FuncTable;<span class="hljs-comment">//函数表</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">targetName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;target&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; NameTable.size(); i++&gt;)&#123;<br><span class="hljs-keyword">if</span>(NameTable[i] == targetName)&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">funcIndex</span> <span class="hljs-operator">=</span> OrderTable[i];<br><span class="hljs-keyword">return</span> FuncTable[funcIndex]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="已知函数序号"><a href="#已知函数序号" class="headerlink" title="已知函数序号"></a>已知函数序号</h3><p>若已知函数序号，则可以直接从函数表中获取函数。</p><p>直接将序号减去Base的值，然后从函数表中获取即可。</p><p>伪代码逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">Base</span> <span class="hljs-operator">=</span> ExportTable.Base;<br>Integer[] FuncTable;<span class="hljs-comment">//函数表</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;<span class="hljs-comment">//已知函数导出序号</span><br><span class="hljs-keyword">return</span> FuncTable[<span class="hljs-number">9</span> - Base];<br></code></pre></td></tr></table></figure><h1 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h1><p>主函数入口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PEStruct.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PE.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PrintExportTable</span><span class="hljs-params">(DATA_EXPORT_DIRECTORY table, lpPEFILE lpPEFile)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//将指定文件加载到内存，并解析PE信息到PEFILE结构体</span><br>PEFILE peFile&#123; <span class="hljs-number">0</span> &#125;;<br>FILE* pFile = fopen(<span class="hljs-string">&quot;D:\\TestDLL.dll&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br><span class="hljs-type">int</span> fileLength = LoadFileToMemory(pFile, &amp;peFile);<br><span class="hljs-type">void</span>* pMemoryBuffer = nullptr;<br>fclose(pFile);<br><br><span class="hljs-keyword">if</span> (peFile.h_pe == nullptr) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>PDATA_EXPORT_DIRECTORY lpExportTable = nullptr;<br>GetExportTable(&amp;lpExportTable, &amp;peFile);<br><span class="hljs-keyword">if</span> (lpExportTable == nullptr) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>PrintExportTable(*lpExportTable, &amp;peFile);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印导出表函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">PrintExportTable</span><span class="hljs-params">(DATA_EXPORT_DIRECTORY table, lpPEFILE lpPEFile)</span> &#123;<br>DWORD imageBase = (DWORD)lpPEFile-&gt;h_dos;<br><br><span class="hljs-type">char</span>* name = (<span class="hljs-type">char</span>*)(Rva2Foa(table.Name, lpPEFile) + imageBase);<br>WORD base = table.Base;<br>DWORD funcNum = table.NumberOfFunctions;<br>DWORD nameNum = table.NumberOfNames;<br>DWORD funcTableRva = table.AddressOfFunctions;<br>DWORD funcTableFoa = Rva2Foa(funcTableRva, lpPEFile) + imageBase;<br>DWORD nameTableRva = table.AddressOfNames;<br>DWORD nameTableFoa = Rva2Foa(nameTableRva, lpPEFile) + imageBase;<br>DWORD orderTableRva = table.AddressOfNameOrdinals;<br>DWORD orderTableFoa = Rva2Foa(orderTableRva, lpPEFile) + imageBase;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;导出表指向文件：%s\r\n&quot;</span>, name);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;起始序号：%d\r\n&quot;</span>, base);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;导出函数总数：%d, 名称导出总数:%d\r\n&quot;</span>, funcNum, nameNum);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;函数表RVA：0x%x, FOA: 0x%x\r\n&quot;</span>, funcTableRva, funcTableFoa);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;名称表RVA：0x%x, FOA: 0x%x\r\n&quot;</span>, nameTableRva, nameTableFoa);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;序号表RVA：0x%x, FOA: 0x%x\r\n&quot;</span>, orderTableRva, orderTableFoa);<br><br>DWORD* nameTable = (DWORD*)nameTableFoa;<br>WORD* orderTable = (WORD*)orderTableFoa;<br>DWORD* funcTable = (DWORD*)funcTableFoa;<br><br><span class="hljs-keyword">for</span> (WORD i = base; i &lt;= funcNum - <span class="hljs-number">1</span> + base; i++) &#123;<br><span class="hljs-keyword">if</span> (funcTable[i-base] == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>WORD order = i;<br><span class="hljs-type">char</span>* name = nullptr;<br>DWORD funcRva = funcTable[i - base];<br>DWORD funcFoa = Rva2Foa(funcRva, lpPEFile);<br>DWORD funcAddr = funcFoa + imageBase;<br><span class="hljs-comment">//搜一下序号表，看能不能找到名字</span><br><span class="hljs-keyword">for</span> (DWORD j = <span class="hljs-number">0</span>; j &lt; nameNum; j++) &#123;<br><span class="hljs-keyword">if</span> (orderTable[j] != i-base) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-comment">//能搜到，拿到名字</span><br>name = (<span class="hljs-type">char</span>*)(Rva2Foa(nameTable[j], lpPEFile) + imageBase);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (name == nullptr) &#123;<br>name = (<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;NO_NAME&quot;</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;函数: %s 的序号是 %d, RVA: 0x%x, FOA: 0x%x 地址:0x%x \r\n&quot;</span>,<br>name, order, funcRva, funcFoa, funcAddr);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>上善若水</category>
      
      <category>PE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>PE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PE结构(3)从磁盘到内存的加载过程</title>
    <link href="/blogs/2024011317470017231.html"/>
    <url>/blogs/2024011317470017231.html</url>
    
    <content type="html"><![CDATA[<h1 id="模拟PE加载过程"><a href="#模拟PE加载过程" class="headerlink" title="模拟PE加载过程"></a>模拟PE加载过程</h1><p>将文件从磁盘load到内存，再从内存中解析PE信息，然后开辟新内存进行“拉伸”操作。</p><h2 id="定义PE结构体"><a href="#定义PE结构体" class="headerlink" title="定义PE结构体"></a>定义PE结构体</h2><p>由于PE中的内容全部是按1字节进行结构体对齐，因此在定义结构体时应当注意对齐方式，以及保存编译环境对齐字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> PE</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PE</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> BYTE, * lpBYTE;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> WORD, * lpWORD;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> DWORD, * lpDWORD;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(push)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PE_HEADER_DOS</span>&#123;</span><br>WORD e_magic;<br>WORD e_cblp;<br>WORD e_cp;<br>WORD e_crlc;<br>WORD e_cparhdr;<br>WORD e_minalloc;<br>WORD e_maxalloc;<br>WORD e_ss;<br>WORD e_sp;<br>WORD e_csum;<br>WORD e_ip;<br>WORD e_cs;<br>WORD e_lfarlc;<br>WORD e_ovno;<br>WORD e_res[<span class="hljs-number">4</span>];<br>WORD e_oemid;<br>WORD e_oeminfo;<br>WORD e_res2[<span class="hljs-number">10</span>];<br>DWORD e_lfanew;<br>&#125;PEHDOS, *lpPEHDOS;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PE_HEADERS_PE</span> &#123;</span><br>DWORD Signature;<br>WORD Machine;<br>WORD NumberOfSections;<br>DWORD TimeDateStamp;<br>DWORD PointerToSymbolTable;<br>DWORD NumberOfSymbols;<br>WORD SizeOfOptionalHeader;<br>WORD Characteristics;<br>&#125;PEHPE, *lpPEHPE;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PE_HEADERS_OPTIONAL</span> &#123;</span><br>WORD Magic;<br>BYTE MajorLinkerVersion;<br>BYTE MinorLinkerVersion;<br>DWORD SizeOfCode;<br>DWORD SizeOfInitializedData;<br>DWORD SizeOfUninitializedData;<br>DWORD AddressOfEntryPoint;<br>DWORD BaseOfCode;<br>DWORD BaseOfData;<br>DWORD ImageBase;<br>DWORD SectionAlignment;<br>DWORD FileAlignment;<br>WORD MajorOperatingSystemVersion;<br>WORD MinorOperatingSystemVersion;<br>WORD MajorImageVersion;<br>WORD MinorImageVersion;<br>WORD MajorSubsystemVersion;<br>WORD MinorSubsystemVersion;<br>DWORD Win32VersionValue;<br>DWORD SizeOfImage;<br>DWORD SizeOfHeader;<br>DWORD CheckSum;<br>WORD Subsystem;<br>WORD DllCharacteristics;<br>DWORD SizeOfStackReserve;<br>DWORD SizeOfStackCommit;<br>DWORD SizeOfHeapReserve;<br>DWORD SizeOfHeapCommit;<br>DWORD LoaderFlags;<br>DWORD NmberOfRvaAndSizes;<br>&#125;PEHOPTIONAL, *lpPEHOPTIONAL;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PE_HEADERS_TABLE_ITEM</span> &#123;</span><br>BYTE name[<span class="hljs-number">8</span>];<br>DWORD VirtualSize;<br>DWORD VirtualAddress;<br>DWORD SizeOfRawData;<br>DWORD PointerToRawData;<br>DWORD PointerToRelocations;<br>DWORD PointerToLinenumbers;<br>WORD NumberOfRelocations;<br>WORD NumberOfLinenumbers;<br>DWORD Characteristics;<br>&#125; PETable, *lpPETable;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(pop)</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PE</span> &#123;</span><br>lpPEHDOS h_dos;<br>lpPEHPE h_pe;<br>lpPEHOPTIONAL h_op;<br>lpPETable pet;<br>&#125;PEFILE, *lpPEFILE;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">LoadFileToMemory</span><span class="hljs-params">(FILE* pFile, lpPEFILE lpPEFile)</span>;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">CreateImageBuffer</span><span class="hljs-params">(lpPEFILE lpPEFile)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">DumpImageToFile</span><span class="hljs-params">(FILE* pFile, <span class="hljs-type">void</span>* imageBase, lpPEFILE lpPEFile)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// !PE.h</span></span><br></code></pre></td></tr></table></figure><h2 id="文件从磁盘到内存"><a href="#文件从磁盘到内存" class="headerlink" title="文件从磁盘到内存"></a>文件从磁盘到内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">LoadFileToMemory</span><span class="hljs-params">(FILE* pFile, lpPEFILE lpPEFile)</span> &#123;<br><span class="hljs-type">int</span> fileLength = <span class="hljs-number">0</span>;<br>fseek(pFile, <span class="hljs-number">0</span>, SEEK_END);<br>fileLength = ftell(pFile);<br>fseek(pFile, <span class="hljs-number">0</span>, SEEK_SET);<br>BYTE* start = new BYTE[fileLength]&#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; fileLength; i++) &#123;<br>start[i] = fgetc(pFile);<br>&#125;<br><span class="hljs-comment">//设置DOS头位置</span><br>lpPEFile-&gt;h_dos = (lpPEHDOS)start;<br><span class="hljs-comment">//设置PE头位置</span><br><span class="hljs-type">int</span> peOffset = lpPEFile-&gt;h_dos-&gt;e_lfanew;<br>lpPEFile-&gt;h_pe = (lpPEHPE)((DWORD)start + peOffset);<br><span class="hljs-comment">//设置OP头位置</span><br>DWORD peAddress = (DWORD)lpPEFile-&gt;h_pe;<br>lpPEFile-&gt;h_op = (lpPEHOPTIONAL)(peAddress + <span class="hljs-number">24</span>);<br><span class="hljs-comment">//设置节表位置</span><br>WORD sizeOfOptionalHeader = lpPEFile-&gt;h_pe-&gt;SizeOfOptionalHeader;<br>lpPEFile-&gt;pet = (lpPETable)(peAddress + <span class="hljs-number">24</span> + sizeOfOptionalHeader);<br><br><span class="hljs-keyword">return</span> fileLength;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解析内存PE信息"><a href="#解析内存PE信息" class="headerlink" title="解析内存PE信息"></a>解析内存PE信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span>* <span class="hljs-title function_">CreateImageBuffer</span><span class="hljs-params">(lpPEFILE peFile)</span> &#123;<br><span class="hljs-comment">//PE属性</span><br>lpPEHDOS lpHdos = peFile-&gt;h_dos;<br><span class="hljs-keyword">if</span> (lpHdos == nullptr) &#123;<br><span class="hljs-keyword">return</span> nullptr;<br>&#125;<br>DWORD imageBaseSrc = (DWORD)lpHdos;<br>lpPEHPE lpHpe = peFile-&gt;h_pe;<br><span class="hljs-keyword">if</span> (lpHpe == nullptr) &#123;<br><span class="hljs-keyword">return</span> nullptr;<br>&#125;<br>lpPEHOPTIONAL lpHop = peFile-&gt;h_op;<br><span class="hljs-keyword">if</span> (lpHop == nullptr) &#123;<br><span class="hljs-keyword">return</span> nullptr;<br>&#125;<br>lpPETable lpTable = peFile-&gt;pet;<br><span class="hljs-keyword">if</span> (lpTable == nullptr) &#123;<br><span class="hljs-keyword">return</span> nullptr;<br>&#125;<br><br><span class="hljs-comment">//开辟内存映像空间</span><br>DWORD sizeOfImage = lpHop-&gt;SizeOfImage;<br><span class="hljs-type">void</span> *pMemoryBuffer = new BYTE[sizeOfImage];<br>DWORD imageBaseDst = (DWORD)pMemoryBuffer;<br><br><span class="hljs-comment">//拷贝PE头</span><br>DWORD sizeOfHeader = lpHop-&gt;SizeOfHeader;<br><span class="hljs-built_in">memcpy</span>(pMemoryBuffer, (<span class="hljs-type">void</span>*)imageBaseSrc, sizeOfHeader);<br><br><span class="hljs-comment">//遍历节表，拷贝每一节</span><br>WORD numberOfSections = lpHpe-&gt;NumberOfSections;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numberOfSections; i++) &#123;<br>lpPETable t = (lpTable + i);<br>DWORD pointerToRawData = t-&gt;PointerToRawData;<br>DWORD sizeOfRawData = t-&gt;SizeOfRawData;<br>DWORD virtualAddress = t-&gt;VirtualAddress;<br><span class="hljs-built_in">memcpy</span>((<span class="hljs-type">void</span>*)(imageBaseDst + virtualAddress), (<span class="hljs-type">void</span>*)(imageBaseSrc + pointerToRawData), sizeOfRawData);<br>&#125;<br><br><span class="hljs-keyword">return</span> pMemoryBuffer;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="从内存中还原到磁盘"><a href="#从内存中还原到磁盘" class="headerlink" title="从内存中还原到磁盘"></a>从内存中还原到磁盘</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">DumpImageToFile</span><span class="hljs-params">(FILE* pFile, <span class="hljs-type">void</span>* imageBase, lpPEFILE peFile)</span> &#123;<br>fseek(pFile, <span class="hljs-number">0</span>, SEEK_SET);<br><br><span class="hljs-comment">//PE属性</span><br>lpPEHDOS lpHdos = peFile-&gt;h_dos;<br><span class="hljs-keyword">if</span> (lpHdos == nullptr) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>lpPEHPE lpHpe = peFile-&gt;h_pe;<br><span class="hljs-keyword">if</span> (lpHpe == nullptr) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>lpPEHOPTIONAL lpHop = peFile-&gt;h_op;<br><span class="hljs-keyword">if</span> (lpHop == nullptr) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>lpPETable lpTable = peFile-&gt;pet;<br><span class="hljs-keyword">if</span> (lpTable == nullptr) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//拷贝PE头</span><br>DWORD sizeOfHeader = lpHop-&gt;SizeOfHeader;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sizeOfHeader; i++) &#123;<br>BYTE byte = *((lpBYTE)imageBase + i);<br>fputc(byte, pFile);<br>&#125;<br><br><span class="hljs-comment">//遍历节表，拷贝每一节</span><br>WORD numberOfSections = lpHpe-&gt;NumberOfSections;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num = <span class="hljs-number">0</span>; num &lt; numberOfSections; num++) &#123;<br>lpPETable t = (lpTable + num);<br>DWORD pointerToRawData = t-&gt;PointerToRawData;<br>DWORD sizeOfRawData = t-&gt;SizeOfRawData;<br>DWORD virtualAddress = t-&gt;VirtualAddress;<br><br>fseek(pFile, pointerToRawData, SEEK_SET);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sizeOfRawData; i++) &#123;<br>BYTE byte = *((lpBYTE)imageBase + virtualAddress + i);<br>fputc(byte, pFile);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PE.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//将指定文件加载到内存，并解析PE信息到PEFILE结构体</span><br>PEFILE peFile&#123; <span class="hljs-number">0</span> &#125;;<br>FILE *pFile = fopen(<span class="hljs-string">&quot;D:\\src.exe&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br><span class="hljs-type">int</span> fileLength = LoadFileToMemory(pFile, &amp;peFile);<br><span class="hljs-type">void</span> *pMemoryBuffer = nullptr;<br>fclose(pFile);<br><br><span class="hljs-comment">//根据PE信息创建内存映像</span><br>pMemoryBuffer = CreateImageBuffer(&amp;peFile);<br><br><span class="hljs-comment">//根据内存映像dump到磁盘</span><br>pFile = fopen(<span class="hljs-string">&quot;D:\\dst.exe&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>);<br>DumpImageToFile(pFile, pMemoryBuffer, &amp;peFile);<br><br>delete[] pMemoryBuffer;<br>delete peFile.h_dos;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>上善若水</category>
      
      <category>PE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>PE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PE结构(2)节表/区块表</title>
    <link href="/blogs/202401112059001543.html"/>
    <url>/blogs/202401112059001543.html</url>
    
    <content type="html"><![CDATA[<h1 id="结构图总览"><a href="#结构图总览" class="headerlink" title="结构图总览"></a>结构图总览</h1><p><img src="/img/post/2024010752947/01.png"></p><h1 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h1><h2 id="偏移计算"><a href="#偏移计算" class="headerlink" title="偏移计算"></a>偏移计算</h2><p>DOS头大小固定64字节，标准PE头固定大小24字节，根据标准PE头中的<strong>SizeOfOptionalHeader</strong>属性可计算 可选PE头长度。</p><p>从标准PE头偏移处开始，计算 24 + <strong>SizeOfOptionalHeader</strong> 即可得到节表偏移量。</p><h2 id="节表项"><a href="#节表项" class="headerlink" title="节表项"></a>节表项</h2><p>节表中一共有<strong>NumberOfSections</strong>个项目,每个项目总计40字节,每项有固定格式如下：</p><table><thead><tr><th align="left">字节数</th><th align="left">名称</th><th align="left">示例值</th><th align="right">备注</th></tr></thead><tbody><tr><td align="left">BYTE[8]</td><td align="left"><strong>NAME</strong></td><td align="left">“.text”</td><td align="right">节名称</td></tr><tr><td align="left">DWORD</td><td align="left">PhysicalAddress&#x2F;VirtualSize</td><td align="left"></td><td align="right">union联合体，存储节内数据在内存中未内存对齐时长度</td></tr><tr><td align="left">DWORD</td><td align="left"><strong>VirtualAddress</strong></td><td align="left"></td><td align="right">该节在内存中的实际偏移量RVA</td></tr><tr><td align="left">DWORD</td><td align="left"><strong>SizeOfRawData</strong></td><td align="left"></td><td align="right">该节在磁盘中实际所占大小，文件对齐</td></tr><tr><td align="left">DWORD</td><td align="left"><strong>PointerToRawData</strong></td><td align="left"></td><td align="right">该节在磁盘中的实际偏移RVA</td></tr><tr><td align="left">DWORD</td><td align="left">PointerToRelocations</td><td align="left"></td><td align="right">无意义</td></tr><tr><td align="left">DWORD</td><td align="left">PointerToLinenumbers</td><td align="left"></td><td align="right">无意义</td></tr><tr><td align="left">WORD</td><td align="left">NumberOfRelocations</td><td align="left"></td><td align="right">无意义</td></tr><tr><td align="left">WORD</td><td align="left">NumberOfLinenumbers</td><td align="left"></td><td align="right">无意义</td></tr><tr><td align="left">DWORD</td><td align="left"><strong>Characteristics</strong></td><td align="left"></td><td align="right">节属性，描述该节可读&#x2F;可写&#x2F;可执行等信息</td></tr></tbody></table><h2 id="编程检验"><a href="#编程检验" class="headerlink" title="编程检验"></a>编程检验</h2><p>C语言实现如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE_READ_PATH <span class="hljs-string">&quot;D:\\test.exe&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE_DOS 64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE_PE 24</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE_TABLE_INDEX 40</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> WORD, *PWORD;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> DWORD, *PDWORD;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">OpenFile</span><span class="hljs-params">(FILE** ppFile)</span> &#123;<br>FILE *pFile = fopen(FILE_READ_PATH, <span class="hljs-string">&quot;rb&quot;</span>);<br><span class="hljs-keyword">if</span> (pFile == nullptr) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>*ppFile = pFile;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Read</span><span class="hljs-params">(FILE* pFile, <span class="hljs-type">void</span>* dst, <span class="hljs-type">int</span> length)</span> &#123;<br><span class="hljs-type">char</span>* pDst = (<span class="hljs-type">char</span>*)dst;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>pDst[i] = fgetc(pFile);<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ReadWord</span><span class="hljs-params">(FILE* pFile, PWORD dst)</span> &#123;<br>Read(pFile, dst, <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ReadDWord</span><span class="hljs-params">(FILE* pFile, PDWORD dst)</span> &#123;<br>Read(pFile, dst, <span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-comment">//获取PE头偏移</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">GetPEHeaderRva</span><span class="hljs-params">(FILE* pFile, PDWORD pNumber)</span> &#123;<br><span class="hljs-keyword">if</span> (pNumber == nullptr) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>fseek(pFile, <span class="hljs-number">0</span>, SEEK_SET);<br>fseek(pFile, SIZE_DOS - <span class="hljs-number">4</span>, SEEK_CUR);<br>ReadDWord(pFile, pNumber);<br>fseek(pFile, <span class="hljs-number">0</span>, SEEK_SET);<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//获取节数量</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">GetNumOfSections</span><span class="hljs-params">(FILE* pFile, DWORD rva, PWORD pNumber)</span> &#123;<br><span class="hljs-keyword">if</span> (pNumber == nullptr) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>fseek(pFile, <span class="hljs-number">0</span>, SEEK_SET);<br>fseek(pFile, rva + <span class="hljs-number">6</span>, SEEK_CUR);<br>ReadWord(pFile, pNumber);<br>fseek(pFile, <span class="hljs-number">0</span>, SEEK_SET);<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//获取可选PE头大小</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">GetNumOfOptional</span><span class="hljs-params">(FILE* pFile, DWORD rva, PWORD pNum)</span> &#123;<br><span class="hljs-keyword">if</span> (pNum == nullptr) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>fseek(pFile, <span class="hljs-number">0</span>, SEEK_SET);<br>fseek(pFile, rva + <span class="hljs-number">20</span>, SEEK_CUR);<br>ReadWord(pFile, pNum);<br>fseek(pFile, <span class="hljs-number">0</span>, SEEK_SET);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//打印节表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PrintfSectionHeader</span><span class="hljs-params">(FILE* pFile, <span class="hljs-type">int</span> rva, <span class="hljs-type">int</span> numOfSections)</span> &#123;<br>fseek(pFile, <span class="hljs-number">0</span>, SEEK_SET);<br>fseek(pFile, rva, SEEK_CUR);<br><br><span class="hljs-type">char</span> name[<span class="hljs-number">9</span>]&#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numOfSections; i++) &#123;<br>Read(pFile, name, <span class="hljs-number">8</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第%d个节Name：%s \r\n&quot;</span>, i+<span class="hljs-number">1</span>, name);<br>fseek(pFile, SIZE_TABLE_INDEX - <span class="hljs-number">8</span>, SEEK_CUR);<br><span class="hljs-built_in">memset</span>(name, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>FILE* file = nullptr;<br><span class="hljs-keyword">if</span> (!OpenFile(&amp;file)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开文件 %s 失败! \r\n&quot;</span>, FILE_READ_PATH);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>DWORD nPEHeaderRVA = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (!GetPEHeaderRva(file, &amp;nPEHeaderRVA)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无法获取PE头偏移! \r\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>WORD numOfSections = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (!GetNumOfSections(file, nPEHeaderRVA, &amp;numOfSections)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无法获取节数量！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>WORD sizeOfOptional = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (!GetNumOfOptional(file, nPEHeaderRVA, &amp;sizeOfOptional)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无法获取OP头长度！\r\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> nSectionsHeaderRVA = nPEHeaderRVA + SIZE_PE + sizeOfOptional;<br>PrintfSectionHeader(file, nSectionsHeaderRVA, numOfSections);<br>&#125;<br></code></pre></td></tr></table></figure><p>程序输出：</p><p><img src="/img/post/202401111543/01.png"></p>]]></content>
    
    
    <categories>
      
      <category>上善若水</category>
      
      <category>PE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>PE</tag>
      
      <tag>节表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PE结构(1)DOS/NT/PE/OP头信息</title>
    <link href="/blogs/2024010716170052947.html"/>
    <url>/blogs/2024010716170052947.html</url>
    
    <content type="html"><![CDATA[<h1 id="结构图总览"><a href="#结构图总览" class="headerlink" title="结构图总览"></a>结构图总览</h1><p><img src="/img/post/2024010752947/01.png"></p><h1 id="DOS-HEAD"><a href="#DOS-HEAD" class="headerlink" title="DOS HEAD"></a>DOS HEAD</h1><p>总计64字节存储DOS头信息</p><table><thead><tr><th align="left">字节数</th><th align="left">名称</th><th align="left">示例值</th><th align="right">备注</th></tr></thead><tbody><tr><td align="left">WORD</td><td align="left"><strong>e_magic</strong></td><td align="left">5A 4D</td><td align="right">标注该文件为可执行文件</td></tr><tr><td align="left">WORD</td><td align="left">e_cblp</td><td align="left">00 90</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">e_cp</td><td align="left">00 03</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">e_crlc</td><td align="left">00 00</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">e_cparhdr</td><td align="left">00 04</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">e_minalloc</td><td align="left">00 00</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">e_maxalloc</td><td align="left">FF FF</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">e_ss</td><td align="left">00 00</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">e_sp</td><td align="left">00 B8</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">e_csum</td><td align="left">00 00</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">e_ip</td><td align="left">00 00</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">e_cs</td><td align="left">00 00</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">e_lfarlc</td><td align="left">00 40</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">e_ovno</td><td align="left">00 00</td><td align="right"></td></tr><tr><td align="left">WORD[4]</td><td align="left">e_res</td><td align="left">00 00</td><td align="right">0000 0000 0000 0000</td></tr><tr><td align="left">WORD</td><td align="left">e_oemid</td><td align="left">00 00</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">e_oeminfo</td><td align="left">00 00</td><td align="right"></td></tr><tr><td align="left">WORD[10]</td><td align="left">e_res2</td><td align="left">00 00</td><td align="right">0000…0000</td></tr><tr><td align="left">DWORD</td><td align="left"><strong>e_lfanew</strong></td><td align="left">00 00 00 F8</td><td align="right">PE文件头偏移量</td></tr></tbody></table><h1 id="NT-HEAD"><a href="#NT-HEAD" class="headerlink" title="NT HEAD"></a>NT HEAD</h1><p>前4字节存储”PE”字符串</p><table><thead><tr><th align="left">字节数</th><th align="left">名称</th><th align="left">示例值</th><th align="right">备注</th></tr></thead><tbody><tr><td align="left">DWORD</td><td align="left"><strong>Signature</strong></td><td align="left">00 00 45 50</td><td align="right">字符串”PE”,由e_lfanew偏移至此</td></tr></tbody></table><h2 id="PE-HEAD"><a href="#PE-HEAD" class="headerlink" title="PE HEAD"></a>PE HEAD</h2><p>中20字节存储PE文件头</p><table><thead><tr><th align="left">字节数</th><th align="left">名称</th><th align="left">示例值</th><th align="right">备注</th></tr></thead><tbody><tr><td align="left">WORD</td><td align="left">Machine</td><td align="left">01 4C</td><td align="right">运行CPU型号 0x0:任意CPU 0x14C:386及后续处理器</td></tr><tr><td align="left">WORD</td><td align="left"><strong>NumberOfSections</strong></td><td align="left">00 02</td><td align="right">区块(节)数量</td></tr><tr><td align="left">DWORD</td><td align="left">TimeDateStamp</td><td align="left">44 62 0B BF</td><td align="right">文件创建(编译)时间</td></tr><tr><td align="left">DWORD</td><td align="left">PointerToSymbolTable</td><td align="left">00 00 00 00</td><td align="right"></td></tr><tr><td align="left">DWORD</td><td align="left">NumberOfSymbols</td><td align="left">00 00 00 00</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left"><strong>SizeOfOptionalHeader</strong></td><td align="left">00 E0</td><td align="right">OP头所占字节长度,32位默认0xE0,64位默认0xF0,可自定义</td></tr><tr><td align="left">WORD</td><td align="left">Characteristics</td><td align="left">01 0F</td><td align="right">位标识器，可执行文件为01 0F</td></tr></tbody></table><h2 id="OPTIONAL-HEAD"><a href="#OPTIONAL-HEAD" class="headerlink" title="OPTIONAL HEAD"></a>OPTIONAL HEAD</h2><table><thead><tr><th align="left">字节数</th><th align="left">名称</th><th align="left">示例值</th><th align="right">备注</th></tr></thead><tbody><tr><td align="left">WORD</td><td align="left">Magic</td><td align="left">01 0B</td><td align="right">0x010B为32位PE文件，0x020B为64位</td></tr><tr><td align="left">BYTE</td><td align="left">MajorLinkerVersion</td><td align="left">07</td><td align="right"></td></tr><tr><td align="left">BYTE</td><td align="left">MinorLinkerVersion</td><td align="left">0A</td><td align="right"></td></tr><tr><td align="left">DWORD</td><td align="left">SizeOfCode</td><td align="left">00 06 C0 00</td><td align="right"></td></tr><tr><td align="left">DWORD</td><td align="left">SizeOfInitializedData</td><td align="left">00 00 C0 00</td><td align="right"></td></tr><tr><td align="left">DWORD</td><td align="left">SizeOfUninitializedData</td><td align="left">00 00 00 00</td><td align="right"></td></tr><tr><td align="left">DWORD</td><td align="left"><strong>AddressOfEntryPoint</strong></td><td align="left">00 00 10 00</td><td align="right">程序执行入口RVA</td></tr><tr><td align="left">DWORD</td><td align="left">BaseOfCode</td><td align="left">00 00 10 00</td><td align="right">代码区块(节)起始RVA，没用</td></tr><tr><td align="left">DWORD</td><td align="left">BaseOfData</td><td align="left">00 06 D0 00</td><td align="right">数据区块(节)起始RVA，没用</td></tr><tr><td align="left">DWORD</td><td align="left"><strong>ImageBase</strong></td><td align="left">00 40 00 00</td><td align="right">文件装载入内存时的首选地址</td></tr><tr><td align="left">DWORD</td><td align="left"><strong>SectionAlignment</strong></td><td align="left">00 00 10 00</td><td align="right">内存中区块(节)对齐长度，一般为0x1000(4KB)</td></tr><tr><td align="left">DWORD</td><td align="left"><strong>FileAlignment</strong></td><td align="left">00 00 02 00</td><td align="right">文件中区块(节)对齐长度</td></tr><tr><td align="left">WORD</td><td align="left">MajorOperatingSystemVersion</td><td align="left">00 04</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">MinorOperatingSystemVersion</td><td align="left">00 00</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">MajorImageVersion</td><td align="left">00 00</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">MinorImageVersion</td><td align="left">00 00</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">MajorSubsystemVersion</td><td align="left">00 04</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">MinorSubsystemVersion</td><td align="left">00 00</td><td align="right"></td></tr><tr><td align="left">DWORD</td><td align="left">Win32VersionValue</td><td align="left">00 00 00 00</td><td align="right"></td></tr><tr><td align="left">DWORD</td><td align="left"><strong>SizeOfImage</strong></td><td align="left">00 07 B0 00</td><td align="right">映像装入内存后总大小,可以比实际值大,但必须是SectionAlignment的整数倍</td></tr><tr><td align="left">DWORD</td><td align="left"><strong>SizeOfHeader</strong></td><td align="left">00 00 04 00</td><td align="right">从S-DOS头部+PE头部+区块表总大小,必须是SectionAlignment的整数倍</td></tr><tr><td align="left">DWORD</td><td align="left"><strong>CheckSum</strong></td><td align="left">00 03 2E 63</td><td align="right">区块的校验和</td></tr><tr><td align="left">WORD</td><td align="left">Subsystem</td><td align="left">00 02</td><td align="right"></td></tr><tr><td align="left">WORD</td><td align="left">DllCharacteristics</td><td align="left">00 00</td><td align="right"></td></tr><tr><td align="left">DWORD</td><td align="left">SizeOfStackReserve</td><td align="left">00 10 00 00</td><td align="right"></td></tr><tr><td align="left">DWORD</td><td align="left">SizeOfStackCommit</td><td align="left">00 00 10 00</td><td align="right"></td></tr><tr><td align="left">DWORD</td><td align="left">SizeOfHeapReserve</td><td align="left">00 10 00 00</td><td align="right"></td></tr><tr><td align="left">DWORD</td><td align="left">SizeOfHeapCommit</td><td align="left">00 00 10 00</td><td align="right"></td></tr><tr><td align="left">DWORD</td><td align="left">LoaderFlags</td><td align="left">00 00 00 00</td><td align="right"></td></tr><tr><td align="left">DWORD</td><td align="left"><strong>NmberOfRvaAndSizes</strong></td><td align="left">00 00 00 10</td><td align="right">数据目录表个数</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>上善若水</category>
      
      <category>PE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>PE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言逆向(3)内存对齐与数组</title>
    <link href="/blogs/2023121510590026419.html"/>
    <url>/blogs/2023121510590026419.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>上善若水</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向,汇编,C,数组,内存对齐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Float的精度问题</title>
    <link href="/blogs/202312141603004009.html"/>
    <url>/blogs/202312141603004009.html</url>
    
    <content type="html"><![CDATA[<h1 id="小学故事《小数点的代价》"><a href="#小学故事《小数点的代价》" class="headerlink" title="小学故事《小数点的代价》"></a>小学故事《小数点的代价》</h1><p>1967年8月23日，前苏联的联盟一号宇宙飞船在返回大气层时，突然发生了恶性事故–减速降落伞无法打开。</p><p>前苏联中央领导研究后决定：向全国实况转播这次事故。当电视台的播音员用沉重的语调宣布，宇宙飞船两个小时后将坠毁，观众将目睹宇航员弗拉迪米-科马洛夫殉难的消息后，举国上下顿时被震撼了，人们沉浸在巨大的悲痛之中。</p><p>科马洛夫的女儿也出现在电视屏幕上，她只有12岁。科马洛夫说：”女儿，你不要哭。””我不哭……”女儿已泣不成声，但她强忍悲痛说：”爸爸，您是苏联英雄，我想告诉您，英雄的女儿会像英雄那样生活的！”</p><p>科马洛夫叮嘱女儿说：”学习时，要认真对待每一个小数点。联盟一号今天发生的一切，<span class="label label-danger">就是因为地面检查时忽略了一个小数点……</span>“</p><div class="note note-info">            <p>首先，文中的故事，尤其是“小数点”这部分，是儿童文学作家虚构的。</p><p>原事故原因极其复杂，有政治因素，也有技术因素，更有大量人为的主观错误。</p><p>我们接下来的讨论是基于这个虚构的故事，不要当真。</p><p><del>所以科马洛夫的女儿好好学习认真对待每一个小数点并不能拯救下一个科马洛夫</del></p>          </div><h1 id="问题的表象"><a href="#问题的表象" class="headerlink" title="问题的表象"></a>问题的表象</h1><p>首先我认为，这个事情不怪地面检查的地勤，一定是俄罗斯程序员的锅 ：）</p><p>假定有如下程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">float</span> a)</span>&#123;<br>  <span class="hljs-keyword">if</span>(a == <span class="hljs-number">3.6f</span>)&#123;<br>    <span class="hljs-comment">//...执行逻辑:打开火箭返回舱的减速降落伞！</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>if</em>语句代码块中的代码真的可以执行吗？什么情况下可以执行、什么情况下不能执行呢？</p><p>再看如下程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> a = <span class="hljs-number">0xFFD4194C</span>;<span class="hljs-comment">//存储减速降落伞的指令编码</span><br><span class="hljs-type">float</span> b = (<span class="hljs-type">float</span>)a;<br></code></pre></td></tr></table></figure><p>这种数据转换真的可以成立吗？变量b中最后存储的还是a中的值吗？</p><p>从科马洛夫老哥最后的结局来看，降落伞最终没打开对吧？</p><p>这就是经常被提及的<strong>浮点数精度</strong>问题，接下来我们研究浮点数为什么会有这种反直觉的问题。</p><h1 id="Float的存储方式"><a href="#Float的存储方式" class="headerlink" title="Float的存储方式"></a>Float的存储方式</h1><div class="note note-info">            <p>在以前的文章中，我们讨论过整数数据在内存中的补码存储。</p><p>传送门: <a href="https://dubhehub.github.io/blogs/2023121316150051854.html">C语言中的数据存储</a></p>          </div><p>但是补码存储，是用来解决减法问题的，并不能解决浮点数存储的问题。</p><p>事实上，浮点数存储在内存结构中的数据，与整数型数据<strong>完全不同</strong>。</p><h2 id="IEEE规范的计算方式"><a href="#IEEE规范的计算方式" class="headerlink" title="IEEE规范的计算方式"></a>IEEE规范的计算方式</h2><p>目前为止，几乎所有我已知的硬件设备厂商，均遵守IEEE规范设计处理器架构，以支持对浮点数的计算。</p><p>当然，也存在因各种原因无法支持IEEE规范，只能通过软件实现该规范的场景，但是那就不在我们的讨论之列了。</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>IEEE规定，对于一个32位数据宽度的单精度浮点数，例如说Float类型变量，有如下存储规范：</p><table><thead><tr><th align="left">最高位</th><th align="left">中8位</th><th align="left">低23位</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0000 0000</td><td align="left">0000 0000 0000 0000 0000 000</td></tr><tr><td align="left">0或1,表示正负符号</td><td align="left">存储8位指数</td><td align="left">存储23位尾数</td></tr></tbody></table><p>可能会感到很奇怪，什么是指数？什么是尾数？</p><p>没事，我们接下来简单复习一下小学数学，也就是科马洛夫的女儿需要“好好学习、认真对待”的那部份 ：）</p><h2 id="计算方式"><a href="#计算方式" class="headerlink" title="计算方式"></a>计算方式</h2><p>以13.5这个浮点数举例，如何计算浮点数存储的位数。</p><h3 id="第一步-转换到二进制格式"><a href="#第一步-转换到二进制格式" class="headerlink" title="第一步:转换到二进制格式"></a>第一步:转换到二进制格式</h3><p>首先将13.5转换为二进制格式：</p><table><thead><tr><th align="center">整数部份</th><th align="center">小数部份</th></tr></thead><tbody><tr><td align="center">1101</td><td align="center">.1000</td></tr></tbody></table><p>即二进制小数: 1101.1</p><h3 id="第二步-转换为科学计数法表示"><a href="#第二步-转换为科学计数法表示" class="headerlink" title="第二步:转换为科学计数法表示"></a>第二步:转换为科学计数法表示</h3><p>接下来将原数转换为科学计数法表示，十进制算术中，我们可以将一万写作: 1 × 10⁴</p><p>所以在二进制中，我们也可以把1101.1写作: 1.1011 × 2³</p><p>小数点从右至左移动了3位，我们将这个3称之为指数，指数需要存储在中间8位。</p><h3 id="第三步-存储符号与指数"><a href="#第三步-存储符号与指数" class="headerlink" title="第三步:存储符号与指数"></a>第三步:存储符号与指数</h3><p>还是看这个表格：</p><table><thead><tr><th align="left">最高位</th><th align="left">中8位</th><th align="left">低23位</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0000 0000</td><td align="left">0000 0000 0000 0000 0000 000</td></tr></tbody></table><p>首先，1.1011 × 2³ 是一个正小数，因此可以填入符号位为0。</p><p>中间的8位指数位是区分正负的，因此在0~255这256个数里区分了<code>[-128,0)和(0,127]</code> 这两个区间。当我们存储指数3时，需要将3进行<em>坐标平移</em>，即对3进行累加127的操作。3+127 &#x3D; 128+2, 128即0x80: 1000 0000。所以中8位是 1000 0010 (128 + 2)。</p><table><thead><tr><th align="left">最高位</th><th align="left">中8位</th><th align="left">低23位</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">1000 0010</td><td align="left">0000 0000 0000 0000 0000 000</td></tr></tbody></table><h3 id="第四步-存储尾数"><a href="#第四步-存储尾数" class="headerlink" title="第四步:存储尾数"></a>第四步:存储尾数</h3><p>1.1011 × 2³ 的指数部份已经存储了，那么接下来存储尾数部份。</p><p>由于科学计数法的性质我们可知：整数部份永远是1。所以在存储1.1011时我们可以省略存储整数部份的1，节约1位存储空间，即尾数等于0.1011</p><p>对于小数来说，在最低有效位之后补0，不会影响小数的大小，所以尾数填入低23位后，不足填充的部份补0:</p><table><thead><tr><th align="left">最高位</th><th align="left">中8位</th><th align="left">低23位</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">1000 0010</td><td align="left">1011 0000 0000 0000 0000 000</td></tr></tbody></table><p>现在我们可以将该数转换为四字节float的16进制表示:</p><table><thead><tr><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th></tr></thead><tbody><tr><td align="left">0100 0001</td><td align="left">0101 1000</td><td align="left">0000 0000</td><td align="left">0000 0000</td></tr><tr><td align="left">41</td><td align="left">58</td><td align="left">00</td><td align="left">00</td></tr></tbody></table><p>即0x41580000</p><div class="note note-info">            <p>float类型的有效存储位其实只有23位，算上偷工减料去掉的整数位上的1，一共是24位。</p><p>此时想想看开头的问题，把一个32位长度的四字节整型数据存储进float里，真的可以存储成功吗？</p>          </div><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>通过 <a href="https://www.toolhelper.cn/Digit/FractionConvert">在线浮点转换</a> 验证我们的计算结果:</p><p><img src="/img/post/202312141603004009/1.png"></p><p>可以看到，计算结果的二进制格式与十六进制格式均与我们计算的一致。</p><p>同理可以计算0.625这个浮点的存储格式，与3.5的步骤一致：</p><span class="label label-info">转换为二进制小数:</span><p>0.625 &#x3D;&gt; 0.101</p><span class="label label-info">转换为科学计数法表示:</span><p>0.101 &#x3D;&gt; 1.01 × 2⁻¹</p><span class="label label-info">指数与尾数:</span><p>符号:正小数</p><p>指数:-1 (即使是负数，也需要坐标平移127，此处-1+127&#x3D;126，即0111 1110)</p><p>尾数:0.01</p><table><thead><tr><th align="left">最高位</th><th align="left">中8位</th><th align="left">低23位</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0111 1110</td><td align="left">0100 0000 0000 0000 0000 000</td></tr></tbody></table><span class="label label-info">转换为float:</span><table><thead><tr><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th></tr></thead><tbody><tr><td align="left">0011 1111</td><td align="left">0010 0000</td><td align="left">0000 0000</td><td align="left">0000 0000</td></tr><tr><td align="left">3F</td><td align="left">20</td><td align="left">00</td><td align="left">00</td></tr></tbody></table><p>即0x3F20000</p><span class="label label-info">验证:</span><p><img src="/img/post/202312141603004009/2.png"></p><p>计算结果的二进制格式与十六进制格式均与我们计算的一致。</p><h2 id="无法存储的浮点数"><a href="#无法存储的浮点数" class="headerlink" title="无法存储的浮点数"></a>无法存储的浮点数</h2><p>当我们尝试存储某些浮点数时，例如0.6。就会发现奇怪的现象，这个浮点数会占满低23位上所有空间。</p><p>明明0.6只是个1位十进制小数，为什么需要这么高的精度来存储呢？</p><h3 id="十进制小数向二进制转换"><a href="#十进制小数向二进制转换" class="headerlink" title="十进制小数向二进制转换"></a>十进制小数向二进制转换</h3><p>当我们尝试将一个10进制小数，例如0.125，转换为二进制小数时，实质上在做如下运算：</p><table><thead><tr><th align="left">计算</th><th align="left">结果</th><th align="left">整数部份</th></tr></thead><tbody><tr><td align="left">0.125*2</td><td align="left">0.25</td><td align="left">0</td></tr><tr><td align="left">0.25*2</td><td align="left">0.5</td><td align="left">0</td></tr><tr><td align="left">0.5*2</td><td align="left">1.0</td><td align="left">1</td></tr></tbody></table><p>当计算结果的小数部份为0时，计算终止，按从上到下的顺序写出其整数部份，即为二进制小数，例如0.125就是二进制小数0.001</p><h3 id="无法结束的运算"><a href="#无法结束的运算" class="headerlink" title="无法结束的运算"></a>无法结束的运算</h3><p>我们尝试用刚刚的方法来计算十进制小数0.6的二进制格式：</p><table><thead><tr><th align="left">计算</th><th align="left">结果</th><th align="left">整数部份</th></tr></thead><tbody><tr><td align="left">0.6*2</td><td align="left">1.2</td><td align="left">1</td></tr><tr><td align="left">0.2*2</td><td align="left">0.4</td><td align="left">0</td></tr><tr><td align="left">0.4*2</td><td align="left">0.8</td><td align="left">0</td></tr><tr><td align="left">0.8*2</td><td align="left">1.6</td><td align="left">1</td></tr><tr><td align="left">0.6*2</td><td align="left">1.2</td><td align="left">1</td></tr></tbody></table><div class="note note-danger">            <p>发现了吗？计算至此，整个计算过程发生了循环，因此该小数在二进制格式下会无限循环：0.100110011001……</p>          </div><p>因此其float格式内存储的是：</p><table><thead><tr><th align="left">最高位</th><th align="left">中8位</th><th align="left">低23位</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0111 1110</td><td align="left">0011 0011 0011 0011 0011 010</td></tr></tbody></table><span class="label label-danger">此处存储空间不足以存下下一个1，所以对最低位进1处理</span><table><thead><tr><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th></tr></thead><tbody><tr><td align="left">0011 1111</td><td align="left">0001 1001</td><td align="left">1001 1001</td><td align="left">1001 1010</td></tr><tr><td align="left">3F</td><td align="left">19</td><td align="left">99</td><td align="left">9A</td></tr></tbody></table><p>那么0x3F19999A存储的这个浮点数，其十进制下是什么呢？</p><p><img src="/img/post/202312141603004009/3.png"></p><div class="note note-info">            <p>0.60000002384185791015625</p><p>由于我们存储该浮点数时，实际上并没有穷尽其尾数，因此这个小数已经不能完全等于原数。</p><p>导致在指定精度到小数点后7位之后，该数与原数已经不再相等。</p>          </div><h1 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h1><p>现在我们已经明白了，float作为单精度浮点数，受限于IEEE规范的存储格式以及二进制小数的特点，实际上不能穷尽小数的尾数。</p><p>因此会发生各种各样的因为浮点数精度导致的BUG。</p><p>看我们这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">float</span> a = <span class="hljs-number">0.6f</span>;<br><br><span class="hljs-type">float</span> b = 计算加速度系数();<span class="hljs-comment">// 如果函数返回的是 0.60000002384185791015625f ? :)</span><br><br><span class="hljs-keyword">if</span>(b &gt; a)&#123;<br>  <span class="hljs-comment">//执行逻辑:当前情况速度过大，需要打开减速降落伞</span><br>  <span class="hljs-comment">//IEEE:不，你不需要打开</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>此时由于精度问题，就会导致本<strong>该执行的代码不被执行</strong>。</p><p>当然，也可能会导致本<strong>不该执行的代码被执行</strong>。</p><p>这完全取决于代码中指定的计算精度在小数点后几位，如果不指定小数位数，就会发生这类计算BUG。</p><p>那么我们如何判断两个浮点数“完全相等”呢？答案是没有办法判断。只能进行“精确到某位小数”下的相等判断，如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">float</span> a = <span class="hljs-number">0.6f</span>;<br><span class="hljs-type">float</span> b = 计算加速度系数();<br><br><span class="hljs-comment">//当两数误差精度在小数点后3位以内时，判定相等</span><br><span class="hljs-keyword">if</span>(b - a &gt;= <span class="hljs-number">-0.001f</span> &amp;&amp; b - a &lt;= <span class="hljs-number">0.001f</span>)&#123;<br>  <span class="hljs-comment">//执行逻辑,打开减速降落伞</span><br>  <span class="hljs-comment">//科马洛夫:对，我当年就差这一行代码！</span><br>&#125;<br><br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>目前已知所有的高级语言，包括商业机构代码，如微软的高精度计算库，均存在类似问题。</p><p>判定小数相等的算法与本文示例原理上并无不同。</p><p><del>所以前苏联程序员要是和哥一样严谨科马洛夫的命就保住了罢</del></p>          </div>]]></content>
    
    
    <categories>
      
      <category>秉科执锐</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>计算机组成原理</tag>
      
      <tag>浮点数</tag>
      
      <tag>float</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言中的数据存储</title>
    <link href="/blogs/2023121316150051854.html"/>
    <url>/blogs/2023121316150051854.html</url>
    
    <content type="html"><![CDATA[<h1 id="减法问题"><a href="#减法问题" class="headerlink" title="减法问题"></a>减法问题</h1><p>以下讨论如无特殊说明，均假定发生在数据宽度为16的情景下，即0x00~0xFF范围。</p><p>在计算机只能支持加法运算的前提下，通过改变存储数据的方式，使其可以支持减法运算。</p><p>让我们来计算 B - A &#x3D; ? 的问题。</p><h2 id="正负数与符号位"><a href="#正负数与符号位" class="headerlink" title="正负数与符号位"></a>正负数与符号位</h2><p>假定需要在0x00～0xFF范围内定义正负数，令0x00～0xFF呈环状排列，即:</p><div class="note note-success">            <p>0-&gt;1-&gt;2-&gt;3-&gt;…-&gt;0xFE-&gt;0xFF-&gt;0-&gt;1-&gt;…</p>          </div><p>则做如下定义:从0至0x7F，表示十进制整数0 ～ 127; 从0x80至0xFF，表示十进制整数-128 ~ -1</p><p>该分法直接将0xFF范围内整数切分为两份，转换为二进制数可发现，最高位为0的数皆为正数，最高位为1的数则为负数。</p><table><thead><tr><th align="left">16进制</th><th align="left">二进制</th><th align="right">最高位</th><th align="right">符号</th></tr></thead><tbody><tr><td align="left">0x5D</td><td align="left">0101 1101</td><td align="right">0</td><td align="right">正数</td></tr><tr><td align="left">0x7F</td><td align="left">0111 0000</td><td align="right">0</td><td align="right">正数</td></tr><tr><td align="left">0x80</td><td align="left">1000 0000</td><td align="right">1</td><td align="right">负数</td></tr><tr><td align="left">0xFF</td><td align="left">1111 1111</td><td align="right">1</td><td align="right">负数</td></tr></tbody></table><div class="note note-primary">            <p>因此得到结论1: <strong>二进制整数的最高位用于充当符号位，符号位为1则表示负数，符号位为0表示正数。</strong></p>          </div><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>将一个二进制数各个位上的数取反，可得到原数的反码形式，形如下列格式:</p><table><thead><tr><th align="left">原码</th><th align="right">反码</th></tr></thead><tbody><tr><td align="left">0000 0000</td><td align="right">1111 1111</td></tr><tr><td align="left">0101 1010</td><td align="right">1010 0101</td></tr></tbody></table><p>取反操作我们用符号表示，对A取反即为~A</p><p>若A是一个0到0xFF范围之间的数，由反码的定义我们容易得出如下结论：A + ~A &#x3D; 0xFF</p><p>例: </p><p>0000 0000 + 1111 1111 &#x3D; 1111 1111(0xFF)</p><p>0101 1010 + 1010 0101 &#x3D; 1111 1111(0xFF)</p><p>由 A + ~A &#x3D; 0xFF 可推出:</p><p>A + ~A + 1 &#x3D; 0x100</p><div class="note note-primary">            <p>结论2: ~A + 1 &#x3D; 0x100 - A</p>          </div><h2 id="减法转换"><a href="#减法转换" class="headerlink" title="减法转换"></a>减法转换</h2><p>原式 B - A，可转换为：</p><p>B + (0x100 - A) - 0x100</p><p>由 <strong>结论2</strong> 可对该式继续转换：</p><p>B + (~A + 1) - 0x100 &#x3D; B - A</p><p>由于A，B两数的数据宽度为16位，即范围在0～0xFF范围内的数，而0x100比A、B均高出了1位。</p><p>A、B没有额外空间存储高出的一位数据，因此无论进位还是借位都无法处理，所以在16位数据宽度下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">B + (~A + 1) - 0x100 = B + (~A + 1)<br></code></pre></td></tr></table></figure><p>即： B + (~A + 1) &#x3D; B - A</p><p>原式从减法被转换为了加法。</p><h3 id="验证计算结果"><a href="#验证计算结果" class="headerlink" title="验证计算结果"></a>验证计算结果</h3><p>接下来我们用<em>8-5</em>这个式子带入进去验证一下(以下算式为显示直观，8位二进制数格式每4位用空格分隔):</p><p>8的二进制格式为0000 1000, 5的二进制格式为0000 0101</p><span class="label label-info">原式B-A:</span><p>0000 1000 - 0000 0101 </p><span class="label label-info">转换为B + (0x100 - A) - 0x100:</span><p>0000 1000 + (1 0000 0000 - 0000 0101) - 1 0000 0000</p><span class="label label-info">转换为B + ~A + 1 -0x100:</span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">0000 1000 + 1111 1010 + 1 - 1 0000 0000<br><br>0000 1000 + 1111 1011 - 1 0000 0000<br><br>1 0000 0011 - 1 0000 0000 = 0000 0011<br></code></pre></td></tr></table></figure><p>0011即十进制的3，<em>8-5&#x3D;3</em> 成立。</p><div class="note note-primary">            <p>得到结论3：B - A &#x3D; B + (~A + 1)</p>          </div><h1 id="求补运算neg"><a href="#求补运算neg" class="headerlink" title="求补运算neg()"></a>求补运算neg()</h1><p>上面我们论证的的<span class="label label-primary">结论3</span>中所定义的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">~A + 1<br></code></pre></td></tr></table></figure><p>该操作被称为<em>求补操作</em>,也即<span class="label label-info">neg()</span>，当我们讨论<span class="label label-info">neg(A)</span>时，实质上就是在讨论 ~A+1</p><p>这就是大学中《计算机组成原理》一课中提到的：<span class="label label-danger">"求原码的补码时，对负数要取反后加一。"</span></p><p>同理，如果我们从内存中读取出一段数据，将其当作整数类型看待时，那么其<em>真值</em>，也可以根据符号位进行转换。</p><div class="note note-info">            <p>如果符号位即最高位是0，则将该数看作有符号数时可以做正数看待。</p><p>如果符号位即最高位是1，则将该数看作有符号数时当作负数看待，需要通过<em>neg()<em>运算获取其</em>真值</em>。</p>          </div><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>念书时对这些概念完全停留在课本、练习题等层面，完全不理解有什么实际意义。</p><p>工作十多年后回过头来看，这些知识其实大有作用。</p>]]></content>
    
    
    <categories>
      
      <category>秉科执锐</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言逆向(2)if语句与JCC</title>
    <link href="/blogs/2023121121101963755.html"/>
    <url>/blogs/2023121121101963755.html</url>
    
    <content type="html"><![CDATA[<p>上一章节的学习后，通过本章节强化加深技能，顺便学习逆向<em>if else</em>结构代码的基础知识。</p><p>if语句的较为典型的标识为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> x1,...<br><span class="hljs-keyword">cmp</span> x1, x2<br>jcc 语句<br></code></pre></td></tr></table></figure><p>如果是带有<em>else</em>代码块的语句，即<em>if else</em>，则类似：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> x1,...<br><span class="hljs-keyword">cmp</span> x1, x2<br>jcc <br>...<br>...<br><span class="hljs-keyword">jmp</span> <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><p>由于<em>if</em>语句与JCC关系密切，可进行查表法：<a href="https://dubhehub.github.io/blogs/2015120616481352488.html">JCC速查</a></p><p>下面通过三道练习题来练习逆向<em>if</em>与<em>if else</em>结构代码。</p><h2 id="练习题1"><a href="#练习题1" class="headerlink" title="练习题1"></a>练习题1</h2><p>分析以下函数：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">00401030</span>   <span class="hljs-keyword">push</span>        <span class="hljs-built_in">ebp</span><br><span class="hljs-number">00401031</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ebp</span>,<span class="hljs-built_in">esp</span><br><span class="hljs-number">00401033</span>   <span class="hljs-keyword">sub</span>         <span class="hljs-built_in">esp</span>,<span class="hljs-number">44h</span><br><span class="hljs-number">00401036</span>   <span class="hljs-keyword">push</span>        <span class="hljs-built_in">ebx</span><br><span class="hljs-number">00401037</span>   <span class="hljs-keyword">push</span>        <span class="hljs-built_in">esi</span><br><span class="hljs-number">00401038</span>   <span class="hljs-keyword">push</span>        <span class="hljs-built_in">edi</span><br><span class="hljs-number">00401039</span>   <span class="hljs-keyword">lea</span>         <span class="hljs-built_in">edi</span>,[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">44h</span>]<br>0040103C   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-number">11h</span><br><span class="hljs-number">00401041</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-number">0CCCCCCCCh</span><br><span class="hljs-number">00401046</span>   <span class="hljs-keyword">rep</span> stos    <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">edi</span>]<br><span class="hljs-number">00401048</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,[004225c4]<br><span class="hljs-number">0040104D</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-built_in">eax</span><br><span class="hljs-number">00401050</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">8</span>]<br><span class="hljs-number">00401053</span>   <span class="hljs-keyword">cmp</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">0Ch</span>]<br><span class="hljs-number">00401056</span>   <span class="hljs-keyword">jg</span>          <span class="hljs-number">00401064</span><br><span class="hljs-number">00401058</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">0Ch</span>]<br>0040105B   <span class="hljs-keyword">add</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>]<br>0040105E   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [004225c4],<span class="hljs-built_in">edx</span><br><span class="hljs-number">00401064</span>   <span class="hljs-keyword">pop</span>         <span class="hljs-built_in">edi</span><br><span class="hljs-number">00401065</span>   <span class="hljs-keyword">pop</span>         <span class="hljs-built_in">esi</span><br><span class="hljs-number">00401066</span>   <span class="hljs-keyword">pop</span>         <span class="hljs-built_in">ebx</span><br><span class="hljs-number">00401067</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">esp</span>,<span class="hljs-built_in">ebp</span><br><span class="hljs-number">00401069</span>   <span class="hljs-keyword">pop</span>         <span class="hljs-built_in">ebp</span><br>0040106A   <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><h3 id="分析参数"><a href="#分析参数" class="headerlink" title="分析参数"></a>分析参数</h3><ol><li>各寄存器没有从外部直接赋值</li><li>函数内使用了<em>ebp+8</em> 与 <em>ebp+0C</em> ，易知栈上有两个参数</li></ol><h3 id="分析局部变量"><a href="#分析局部变量" class="headerlink" title="分析局部变量"></a>分析局部变量</h3><p>函数内仅使用<em>ebp-4</em>一处局部变量</p><h3 id="分析全局变量"><a href="#分析全局变量" class="headerlink" title="分析全局变量"></a>分析全局变量</h3><p>根据:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,[004225c4]<br></code></pre></td></tr></table></figure><p>可知[0x004225c4]为一处全局变量</p><h3 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">00401048</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,[004225c4]<br><span class="hljs-comment">; a = global</span><br><span class="hljs-number">0040104D</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-built_in">eax</span><br><span class="hljs-number">00401050</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">8</span>]<br><span class="hljs-comment">; if(p1 &lt;= p2) &#123;</span><br><span class="hljs-number">00401053</span>   <span class="hljs-keyword">cmp</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">0Ch</span>]<br><span class="hljs-number">00401056</span>   <span class="hljs-keyword">jg</span>          <span class="hljs-number">00401064</span><br><span class="hljs-comment">;   global += p2</span><br><span class="hljs-number">00401058</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">0Ch</span>]<br>0040105B   <span class="hljs-keyword">add</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>]<br>0040105E   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [004225c4],<span class="hljs-built_in">edx</span><br><span class="hljs-comment">; &#125;</span><br><span class="hljs-number">00401064</span>   <span class="hljs-keyword">pop</span>         <span class="hljs-built_in">edi</span><br></code></pre></td></tr></table></figure><p>可知该函数功能为：如果参数1小于等于参数2，则将参数2累加到全局变量中。</p><h3 id="返回值分析"><a href="#返回值分析" class="headerlink" title="返回值分析"></a>返回值分析</h3><p>函数直到尾声也没有清空eax内的值，也未对eax的值进行更新，可知返回值为全局变量累加之前存储的数值</p><h3 id="还原成C函数"><a href="#还原成C函数" class="headerlink" title="还原成C函数"></a>还原成C函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> global;<br><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2)</span>&#123;<br>  <span class="hljs-type">int</span> a = global;<br>  <span class="hljs-keyword">if</span>(p1 &lt;= p2)&#123;<br>    globat+=p2;<br>  &#125;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="练习题2"><a href="#练习题2" class="headerlink" title="练习题2"></a>练习题2</h2><p>分析以下函数：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">004010B0   <span class="hljs-keyword">push</span>        <span class="hljs-built_in">ebp</span><br>004010B1   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ebp</span>,<span class="hljs-built_in">esp</span><br>004010B3   <span class="hljs-keyword">sub</span>         <span class="hljs-built_in">esp</span>,<span class="hljs-number">48h</span><br>004010B6   <span class="hljs-keyword">push</span>        <span class="hljs-built_in">ebx</span><br>004010B7   <span class="hljs-keyword">push</span>        <span class="hljs-built_in">esi</span><br>004010B8   <span class="hljs-keyword">push</span>        <span class="hljs-built_in">edi</span><br>004010B9   <span class="hljs-keyword">lea</span>         <span class="hljs-built_in">edi</span>,[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">48h</span>]<br>004010BC   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-number">12h</span><br>004010C1   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-number">0CCCCCCCCh</span><br>004010C6   <span class="hljs-keyword">rep</span> stos    <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">edi</span>]<br>004010C8   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,[004225c4]<br>004010CD   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-built_in">eax</span><br>004010D0   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>],<span class="hljs-number">2</span><br>004010D7   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">8</span>]<br>004010DA   <span class="hljs-keyword">cmp</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">0Ch</span>]<br>004010<span class="hljs-built_in">DD</span>   <span class="hljs-keyword">jl</span>          004010e8<br>004010DF   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]<br>004010E2   <span class="hljs-keyword">add</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-number">1</span><br>004010E5   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>],<span class="hljs-built_in">edx</span><br>004010E8   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">8</span>]<br>004010EB   <span class="hljs-keyword">cmp</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">0Ch</span>]<br>004010EE   <span class="hljs-keyword">jge</span>         004010fb<br>004010F0   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]<br>004010F3   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [004225c4],<span class="hljs-built_in">ecx</span><br>004010F9   <span class="hljs-keyword">jmp</span>         <span class="hljs-number">00401107</span><br>004010FB   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>]<br>004010FE   <span class="hljs-keyword">add</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]<br><span class="hljs-number">00401101</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [004225c4],<span class="hljs-built_in">edx</span><br><span class="hljs-number">00401107</span>   <span class="hljs-keyword">pop</span>         <span class="hljs-built_in">edi</span><br><span class="hljs-number">00401108</span>   <span class="hljs-keyword">pop</span>         <span class="hljs-built_in">esi</span><br><span class="hljs-number">00401109</span>   <span class="hljs-keyword">pop</span>         <span class="hljs-built_in">ebx</span><br>0040110A   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">esp</span>,<span class="hljs-built_in">ebp</span><br>0040110C   <span class="hljs-keyword">pop</span>         <span class="hljs-built_in">ebp</span><br><span class="hljs-number">0040110D</span>   <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><h3 id="分析参数-1"><a href="#分析参数-1" class="headerlink" title="分析参数"></a>分析参数</h3><ol><li>各寄存器没有从外部直接赋值</li><li>函数内使用了<em>ebp+8</em> 与 <em>ebp+0C</em> ，易知栈上有两个参数</li></ol><h3 id="分析局部变量-1"><a href="#分析局部变量-1" class="headerlink" title="分析局部变量"></a>分析局部变量</h3><p>函数内仅使用<em>ebp-4</em>与<em>ebp-8</em>两个局部变量</p><h3 id="分析全局变量-1"><a href="#分析全局变量-1" class="headerlink" title="分析全局变量"></a>分析全局变量</h3><p>根据:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,[004225c4]<br></code></pre></td></tr></table></figure><p>可知[0x004225c4]为一处全局变量</p><h3 id="分析功能"><a href="#分析功能" class="headerlink" title="分析功能"></a>分析功能</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; int a = global</span><br>004010C8   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,[004225c4]<br>004010CD   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-built_in">eax</span><br><span class="hljs-comment">; int b = 2</span><br>004010D0   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>],<span class="hljs-number">2</span><br><span class="hljs-comment">; if(p1 &gt;= p2)&#123;</span><br>004010D7   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">8</span>]<br>004010DA   <span class="hljs-keyword">cmp</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">0Ch</span>]<br>004010<span class="hljs-built_in">DD</span>   <span class="hljs-keyword">jl</span>          004010e8<br><span class="hljs-comment">;   b+=1</span><br>004010DF   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]<br>004010E2   <span class="hljs-keyword">add</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-number">1</span><br>004010E5   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>],<span class="hljs-built_in">edx</span><br><span class="hljs-comment">; &#125; </span><br><span class="hljs-comment">; if(p1 &lt; p2) &#123;</span><br>004010E8   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">8</span>]<br>004010EB   <span class="hljs-keyword">cmp</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">0Ch</span>]<br>004010EE   <span class="hljs-keyword">jge</span>         004010fb<br><span class="hljs-comment">;   global = b</span><br>004010F0   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]<br>004010F3   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [004225c4],<span class="hljs-built_in">ecx</span><br>004010F9   <span class="hljs-keyword">jmp</span>         <span class="hljs-number">00401107</span><br><span class="hljs-comment">; &#125; </span><br><span class="hljs-comment">; else &#123;</span><br><span class="hljs-comment">;   global = a + b</span><br>004010FB   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>]<br>004010FE   <span class="hljs-keyword">add</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]<br><span class="hljs-number">00401101</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [004225c4],<span class="hljs-built_in">edx</span><br><span class="hljs-comment">; &#125;</span><br><span class="hljs-number">00401107</span>   <span class="hljs-keyword">pop</span>         <span class="hljs-built_in">edi</span><br><span class="hljs-number">00401108</span>   <span class="hljs-keyword">pop</span>         <span class="hljs-built_in">esi</span><br></code></pre></td></tr></table></figure><h3 id="分析返回值"><a href="#分析返回值" class="headerlink" title="分析返回值"></a>分析返回值</h3><p>函数永远返回第一个参数</p><h3 id="还原成C函数-1"><a href="#还原成C函数-1" class="headerlink" title="还原成C函数"></a>还原成C函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> global;<br><span class="hljs-type">int</span> <span class="hljs-title function_">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2)</span>&#123;<br>  <span class="hljs-type">int</span> a = global;<br>  <span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span>(p1 &gt;= p2)&#123;<br>      b+=<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(p1 &lt; p2)&#123;<br>    global = b;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    global = a + b;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p1;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="练习题3"><a href="#练习题3" class="headerlink" title="练习题3"></a>练习题3</h2><p>分析以下函数：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">004010B0   <span class="hljs-keyword">push</span>        <span class="hljs-built_in">ebp</span><br>004010B1   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ebp</span>,<span class="hljs-built_in">esp</span><br>004010B3   <span class="hljs-keyword">sub</span>         <span class="hljs-built_in">esp</span>,<span class="hljs-number">4Ch</span><br>004010B6   <span class="hljs-keyword">push</span>        <span class="hljs-built_in">ebx</span><br>004010B7   <span class="hljs-keyword">push</span>        <span class="hljs-built_in">esi</span><br>004010B8   <span class="hljs-keyword">push</span>        <span class="hljs-built_in">edi</span><br>004010B9   <span class="hljs-keyword">lea</span>         <span class="hljs-built_in">edi</span>,[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4Ch</span>]<br>004010BC   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-number">13h</span><br>004010C1   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-number">0CCCCCCCCh</span><br>004010C6   <span class="hljs-keyword">rep</span> stos    <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">edi</span>]<br>004010C8   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-number">0</span><br>004010CF   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>],<span class="hljs-number">1</span><br>004010D6   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0Ch</span>],<span class="hljs-number">2</span><br>004010<span class="hljs-built_in">DD</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">8</span>]<br>004010E0   <span class="hljs-keyword">cmp</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">0Ch</span>]<br>004010E3   <span class="hljs-keyword">jg</span>         004010f0<br>004010E5   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]<br>004010E8   <span class="hljs-keyword">sub</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-number">1</span><br>004010EB   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-built_in">ecx</span><br>004010EE   <span class="hljs-keyword">jmp</span>         <span class="hljs-number">00401123</span><br>004010F0   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">0Ch</span>]<br>004010F3   <span class="hljs-keyword">cmp</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">10h</span>]<br>004010F6   <span class="hljs-keyword">jl</span>          <span class="hljs-number">00401103</span><br>004010F8   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0Ch</span>]<br>004010FB   <span class="hljs-keyword">add</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-number">1</span><br>004010FE   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-built_in">eax</span><br><span class="hljs-number">00401101</span>   <span class="hljs-keyword">jmp</span>         <span class="hljs-number">00401123</span><br><span class="hljs-number">00401103</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">8</span>]<br><span class="hljs-number">00401106</span>   <span class="hljs-keyword">cmp</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">10h</span>]<br><span class="hljs-number">00401109</span>   <span class="hljs-keyword">jle</span>         <span class="hljs-number">00401116</span><br>0040110B   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]<br>0040110E   <span class="hljs-keyword">add</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0Ch</span>]<br><span class="hljs-number">00401111</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-built_in">edx</span><br><span class="hljs-number">00401114</span>   <span class="hljs-keyword">jmp</span>         <span class="hljs-number">00401123</span><br><span class="hljs-number">00401116</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0Ch</span>]<br><span class="hljs-number">00401119</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]<br>0040111C   <span class="hljs-keyword">lea</span>         <span class="hljs-built_in">edx</span>,[<span class="hljs-built_in">ecx</span>+<span class="hljs-built_in">eax</span>-<span class="hljs-number">1</span>]<br><span class="hljs-number">00401120</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-built_in">edx</span><br><span class="hljs-number">00401123</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>]<br><span class="hljs-number">00401126</span>   <span class="hljs-keyword">add</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-number">1</span><br><span class="hljs-number">00401129</span>   <span class="hljs-keyword">pop</span>         <span class="hljs-built_in">edi</span><br>0040112A   <span class="hljs-keyword">pop</span>         <span class="hljs-built_in">esi</span><br>0040112B   <span class="hljs-keyword">pop</span>         <span class="hljs-built_in">ebx</span><br>0040112C   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">esp</span>,<span class="hljs-built_in">ebp</span><br>0040112E   <span class="hljs-keyword">pop</span>         <span class="hljs-built_in">ebp</span><br>0040112F   <span class="hljs-keyword">ret</span><br><br></code></pre></td></tr></table></figure><h3 id="分析参数-2"><a href="#分析参数-2" class="headerlink" title="分析参数"></a>分析参数</h3><p>函数内各条件分支判断条件，均使用了<em>ebp + 0x8</em>、<em>epb + 0xc</em>、<em>ebp + 0x10</em>，各寄存器均没有提前赋值，可知栈上有三个参数。</p><h3 id="分析局部变量-2"><a href="#分析局部变量-2" class="headerlink" title="分析局部变量"></a>分析局部变量</h3><p>函数内共有3个局部变量，分别是<em>ebp - 4</em>、<em>ebp - 8</em> 、<em>ebp - c</em>，初始值分别为0、1、2</p><h3 id="分析全局变量-2"><a href="#分析全局变量-2" class="headerlink" title="分析全局变量"></a>分析全局变量</h3><p>函数内未使用全局变量</p><h3 id="分析功能-1"><a href="#分析功能-1" class="headerlink" title="分析功能"></a>分析功能</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; int a = 0</span><br>004010C8   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-number">0</span><br><span class="hljs-comment">; int b = 1</span><br>004010CF   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>],<span class="hljs-number">1</span><br><span class="hljs-comment">; int c = 2</span><br>004010D6   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0Ch</span>],<span class="hljs-number">2</span><br><span class="hljs-comment">; if(p1 &lt;= p2) &#123;</span><br>004010<span class="hljs-built_in">DD</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">8</span>]<br>004010E0   <span class="hljs-keyword">cmp</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">0Ch</span>]<br>004010E3   <span class="hljs-keyword">jg</span>          004010f0<br><span class="hljs-comment">;   a = b - 1</span><br>004010E5   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]<br>004010E8   <span class="hljs-keyword">sub</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-number">1</span><br>004010EB   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-built_in">ecx</span><br>004010EE   <span class="hljs-keyword">jmp</span>         <span class="hljs-number">00401123</span><br><span class="hljs-comment">; &#125;</span><br><span class="hljs-comment">; else if(p2 &gt;= p3)&#123;</span><br>004010F0   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">0Ch</span>]<br>004010F3   <span class="hljs-keyword">cmp</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">10h</span>]<br>004010F6   <span class="hljs-keyword">jl</span>          <span class="hljs-number">00401103</span><br><span class="hljs-comment">;   a = c + 1</span><br>004010F8   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0Ch</span>]<br>004010FB   <span class="hljs-keyword">add</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-number">1</span><br>004010FE   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-built_in">eax</span><br><span class="hljs-number">00401101</span>   <span class="hljs-keyword">jmp</span>         <span class="hljs-number">00401123</span><br><span class="hljs-comment">; &#125;</span><br><span class="hljs-comment">; else if (p1 &gt; p3)&#123;</span><br><span class="hljs-number">00401103</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">8</span>]<br><span class="hljs-number">00401106</span>   <span class="hljs-keyword">cmp</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">10h</span>]<br><span class="hljs-number">00401109</span>   <span class="hljs-keyword">jle</span>         <span class="hljs-number">00401116</span><br><span class="hljs-comment">;   a = b + c</span><br>0040110B   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]<br>0040110E   <span class="hljs-keyword">add</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0Ch</span>]<br><span class="hljs-number">00401111</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-built_in">edx</span><br><span class="hljs-number">00401114</span>   <span class="hljs-keyword">jmp</span>         <span class="hljs-number">00401123</span><br><span class="hljs-comment">; &#125;</span><br><span class="hljs-comment">; else &#123;</span><br><span class="hljs-comment">;   a = c + b - 1</span><br><span class="hljs-number">00401116</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0Ch</span>]<br><span class="hljs-number">00401119</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]<br>0040111C   <span class="hljs-keyword">lea</span>         <span class="hljs-built_in">edx</span>,[<span class="hljs-built_in">ecx</span>+<span class="hljs-built_in">eax</span>-<span class="hljs-number">1</span>]<br><span class="hljs-number">00401120</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-built_in">edx</span><br><span class="hljs-comment">; &#125;</span><br><span class="hljs-number">00401123</span>   <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>]<br><span class="hljs-comment">; return a + 1</span><br><span class="hljs-number">00401126</span>   <span class="hljs-keyword">add</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-number">1</span><br><span class="hljs-number">00401129</span>   <span class="hljs-keyword">pop</span>         <span class="hljs-built_in">edi</span><br>0040112A   <span class="hljs-keyword">pop</span>         <span class="hljs-built_in">esi</span><br></code></pre></td></tr></table></figure><h3 id="分析返回值-1"><a href="#分析返回值-1" class="headerlink" title="分析返回值"></a>分析返回值</h3><p>函数最终返回局部变量a，即<em>ebp-4</em>的值。</p><p>返回时会在a的基础上再加1。</p><h3 id="还原成C函数-2"><a href="#还原成C函数-2" class="headerlink" title="还原成C函数"></a>还原成C函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">func3</span><span class="hljs-params">(<span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2, <span class="hljs-type">int</span> p3)</span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> c = <span class="hljs-number">2</span>;<br><br>  <span class="hljs-keyword">if</span>(p1 &lt;= p2)&#123;<br>    a = b - <span class="hljs-number">1</span>;<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p2 &gt;= p3)&#123;<br>    a = c + <span class="hljs-number">1</span>;<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p1 &gt; p3)&#123;<br>    a = b + c;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    a = c + b - <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>上善若水</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
      <tag>逆向</tag>
      
      <tag>C</tag>
      
      <tag>if else</tag>
      
      <tag>jcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章:逆向TraceMe.exe</title>
    <link href="/blogs/202312101836546247.html"/>
    <url>/blogs/202312101836546247.html</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Sorry, this password doesn't seem to be correct, please try again." data-whm="Sorry, this article cannot be verified, but you can still view the decrypted content.">  <script id="hbeData" type="hbeData" data-hmacdigest="80c476195dc80173fc232c7ae41af5d59b6f468b96a7a43f6d69ea835dfb5cdb">e4a246d87dcdf3875da5cbd5b35f78b7649d42942d7bb57b8435fb0da6d82c6d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hello, a password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>《加密与解密 第四版》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>confidential</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随书文件</title>
    <link href="/blogs/2023120921430012359.html"/>
    <url>/blogs/2023120921430012359.html</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Sorry, this password doesn't seem to be correct, please try again." data-whm="Sorry, this article cannot be verified, but you can still view the decrypted content.">  <script id="hbeData" type="hbeData" data-hmacdigest="484665f1c805a124935a5a9ba5e1ba2514a6bc3c63ce409b9b36ad6edd044b33">e4a246d87dcdf3875da5cbd5b35f78b7442cb6290c44ce0cf09f4d7cad6ef30658fef6bb910d5be6fa40384944453695695c013c12ab1a2a4210d93e4fa5a2f1f5cfb1d52462e8aa47d6ce0169b99142abe5460c3ac106b5c5636b85284d1583e819fd765b2cc2ff99c6b871d3addef8dbf518a64f877edc7ecd34130775bff937902202403ead524e55cdeadf5227fc19635dc9d14b98ab07dc088e95c4c4f125d3a00c1defd474db6a29746d3fdefaec95bdf1a1dc24621271f8cc4e7703f180449319fdafd8d9501418892d8a24b479ad8d058e6e6522b0f84cb690ba1fdfc51faca546d07eaa8743ed11fa1dee2a6b545065fb9c0cd989cb3de9567c98f8ee9bb975b3a068498f68ccf8fba1073b515f516b59af093a26fdcb2f211c22fe4bcbc3cb7c4fd5812480bc30f6c71f94c7e288030341ad7b4abd7947f172bc0a71109fc7c12c1846489ab6c3ee27135a4a9c9aa686bd0186403c320c9c1ccd29f6eede80778310dbe9b5e07de123cf9be07eb34f7636e64b40d0db344db26944765be8828ea9d794f0bcf8429ecaea3e73c3e99d06f5aa9e18122f92171b6400571d2865a9cb7d403b75513eed5081d87c71d6478a69f256a0c9e950b2e9c26d6106d8eabce87c74ef915119795f472693dee9aaf73d24108f354a9b9a70deb3aea9edfa5579e52cf9f6e13933c0f379b92bd4d403f184f390c9da051cd8d9d34217435e0062df3a9b83f035cc72cd5199da95fbba680e9f56fbede6ec59af841c34c5626c3bd08420727ee8bea1b239bfafd18373c399596ca503d445d105653ac263336cb6890694c62a0481d7d7b7e17118cb97b7bc9cc4d8d647cfd64c583fd8e45e7002691dd00248ceeb83911c4a1a8d080b793a3b7b81447958871ef6989bb8cf826deb2bdb918bcfa04be455715c1292f322c796456a119edf496712328ad0dc0fb5bd680caa54c4b166aeb87bd69935bfc6fddab0ea5e88a840d7a3649eb8f03371c338c62cb179cf59f90d0f9de62bf6ac99175e87fd3afa4c0a0564c50f510e8860f1f0932162203e4f35d50662ecb9ab1b8e99e781a34112dd78fe8fd2bd17600103e2c954003db6ac51b77d3cdf62dfae22317ad6eb07d4aa961a4c08a1f3e94664fd4643aedc563ed4f7ded2969b1afed49f4ec0ffe8d8eb4abb1e503b29c9bf000e86c9a4e7651733e17676f2f92c65e31e91213d25f1bc6a863b568f59edcd00fb0ea4935694be6ff8f63b474d359083fbc9ee9c53e37eb368af93caba66d7a3a0e851c06bcd0a8613641552354111d79f9523c26581f3587896a29512b37b6ba331e0208246f24ddd1ad0a2c00603481e67b3bebdee35cddfbc93bc86449b6ad6a57d484e46322d9fda25489164dbd39e884512c0d82da4660f114651814dcda86accb2dac40e41402856e969f68abb7af4d4ab1c58ca744aac87cf9a10027c133469eb76cdfcf3d1ce5f5ae9a17f48390cc69c1dd1e99a27e6aa7b53f8d4b3691a0372e38a05a16e5a37989f831f88b795b1089b9cd9f6467fcb8c9efe25f5ba8e5826cd20c157be15cd5184b53866b52fe209d51bd37e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hello, a password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>《加密与解密 第四版》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>confidential</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言逆向(1)函数调用</title>
    <link href="/blogs/202312081021542315.html"/>
    <url>/blogs/202312081021542315.html</url>
    
    <content type="html"><![CDATA[<h2 id="C风格函数"><a href="#C风格函数" class="headerlink" title="C风格函数"></a>C风格函数</h2><p>在正式开始前，我们先讨论在C语言中实现各类逻辑功能的载体：函数。</p><p>一个标准的C语言程序“HelloWorld.c”可能会写作如下结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argNums, <span class="hljs-type">char</span>* args[], <span class="hljs-type">void</span>* envir)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段程序以<em>main</em>函数作为程序的入口，展开自己的逻辑：输出“Hello World！”</p><p>那么函数在汇编层面是怎么表示的呢？如何将参数传递给函数，函数又如何将返回值传递给调用者？</p><p>这就需要了解函数的调用约定。</p><h3 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h3><p>在无特别说明的情况下，32位编译器会将C代码按cdecl约定进行编译。</p><p>在32位汇编层面，我们有如下函数调用约定：</p><table><thead><tr><th align="left">约定</th><th align="center">参数传递</th><th align="right">栈平衡</th></tr></thead><tbody><tr><td align="left">cdecl</td><td align="center">从右到左依次压栈</td><td align="right">外平栈(调用者负责平衡栈)</td></tr><tr><td align="left">stdcall</td><td align="center">从右到左依次压栈</td><td align="right">内平栈(函数内部平衡栈，无需调用者参与)</td></tr><tr><td align="left">fastcall</td><td align="center">前两个参数依次放入ECX,EDX寄存器，其他参数从右到左依次压栈</td><td align="right">内平栈</td></tr></tbody></table><p>在x64汇编环境下，仅有fastcall一种调用约定，前四个参数依次放入RCX,RDX,R8,R9四个寄存器，其他参数从右到左依次压栈，函数内部平栈。</p><p>汇编程序通过 <em>栈</em> 结构将参数传递给函数，实际上函数内部使用的局部变量也存储在栈空间上。</p><h2 id="Windows系统的栈设计"><a href="#Windows系统的栈设计" class="headerlink" title="Windows系统的栈设计"></a>Windows系统的栈设计</h2><p>栈空间的总量由系统分配，从高内存向低内存扩展，即内存减少为栈抬高的方向。</p><p>通俗来说:</p><p>执行压栈指令<em>push</em>时，栈顶指向的内存地址将减少；</p><p>执行弹栈指令 <em>pop</em>时，栈顶指向的内存地址将增加。</p><h3 id="函数序言"><a href="#函数序言" class="headerlink" title="函数序言"></a>函数序言</h3><p>多数C风格函数的入口会有如下代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br></code></pre></td></tr></table></figure><p>ebp存储了栈底空间地址，此代码在函数入口将ebp压栈，保存了之前的栈底，确保栈帧之间的连续性。</p><p>这段代码也被称为<strong>函数序言</strong>， 需要注意的是，不一定所有的C语言函数都严格遵守这个规则。</p><h3 id="栈空间"><a href="#栈空间" class="headerlink" title="栈空间"></a>栈空间</h3><h4 id="栈帧指针"><a href="#栈帧指针" class="headerlink" title="栈帧指针"></a>栈帧指针</h4><p>esp寄存器在不进行人为干涉的情况下，始终存储栈顶地址。</p><p>使用pop，push，call，ret等指令时，都会影响esp寄存器的值。</p><p>esp寄存器也被称为<strong>栈帧指针</strong></p><h4 id="帧基指针"><a href="#帧基指针" class="headerlink" title="帧基指针"></a>帧基指针</h4><p>由于ebp寄存器始终存储栈底，即栈帧的基地址，所以ebp寄存器也被称为<strong>帧基指针</strong>。</p><p>常见的使用方式：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">ebp</span>] <span class="hljs-comment">;获取上一帧的帧基地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">ebp</span>+<span class="hljs-number">0x04</span>] <span class="hljs-comment">;获取函数返回地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">ebp</span>+<span class="hljs-number">0x08</span>] <span class="hljs-comment">;获取函数的第一个参数</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0x04</span>] <span class="hljs-comment">;获取函数的第一个局部变量</span><br></code></pre></td></tr></table></figure><h4 id="局部变量缓冲区"><a href="#局部变量缓冲区" class="headerlink" title="局部变量缓冲区"></a>局部变量缓冲区</h4><p>在函数序言结束后，如果函数内部需要使用局部变量，一般会在栈上开辟局部变量的空间。</p><p>部分编译器(如微软的msvs)在debug模式下编译C语言代码时，会在局部变量空间内填充0xCC，即int 3中断。</p><p>形如下面格式：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">0x40</span> <span class="hljs-comment">;开辟64字节的局部变量空间</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebx</span>      <br><span class="hljs-keyword">push</span> <span class="hljs-built_in">esi</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">edi</span>      <span class="hljs-comment">;保存现场</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">edi</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">ebp</span> - <span class="hljs-number">0x40</span>]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">0xcccccccc</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">0x10</span><br><span class="hljs-keyword">rep</span> <span class="hljs-keyword">stosd</span>     <span class="hljs-comment">;将开辟出的64字节空间全部用0xcc填充</span><br></code></pre></td></tr></table></figure><h3 id="函数尾声"><a href="#函数尾声" class="headerlink" title="函数尾声"></a>函数尾声</h3><p>在函数即将结束时，会销毁开辟的栈空间，并将帧指针与帧基指针还原到函数调用时的状态。</p><p>形如下面格式：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">pop</span> <span class="hljs-built_in">edi</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">esi</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>, <span class="hljs-built_in">ebp</span> <span class="hljs-comment">;销毁栈空间</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span>      <span class="hljs-comment">;还原帧基指针</span><br><span class="hljs-keyword">ret</span>          <span class="hljs-comment">;变形即 pop eip</span><br></code></pre></td></tr></table></figure><p>这样的模板代码也被称为<strong>函数尾声</strong>，需要注意的是，与<strong>函数序言</strong>相同，并不是所有函数都严格遵守这个形式。</p><h3 id="栈平衡"><a href="#栈平衡" class="headerlink" title="栈平衡"></a>栈平衡</h3><p>由于参数通过栈结构传递，因此函数的调用需要保证:</p><p><strong>函数调用前后的esp&#x2F;ebp寄存器值相同，即栈平衡。</strong></p><p><strong>cdecl</strong>风格的函数一般定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> __cdecl <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>;<br></code></pre></td></tr></table></figure><p>该函数由调用者平衡栈，即:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">ebp</span> - <span class="hljs-number">0x04</span>]<br><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebx</span>            <span class="hljs-comment">;参数入栈</span><br><span class="hljs-keyword">call</span> func           <span class="hljs-comment">;调用函数</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">0x04</span>       <span class="hljs-comment">;平衡栈</span><br></code></pre></td></tr></table></figure><h2 id="空函数与裸函数区别"><a href="#空函数与裸函数区别" class="headerlink" title="空函数与裸函数区别"></a>空函数与裸函数区别</h2><p>在C语言中，空函数与裸函数对编译器而言完全不同，如下形式的两个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> __declspec(naked) naked_func(<span class="hljs-type">int</span> i)&#123;<br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">empty_func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>被 <em>__declspec(naked)</em> 修饰的函数 <em>naked_func</em> 在编译阶段不会生成任何汇编代码，所有工作都需要编码者自行实现。</p><p>而空函数 <em>empty_func</em> 中虽然也没有写任何程序逻辑，但是编译器会为其生成 <strong>函数序言</strong> 、 <strong>函数尾声</strong> 等模板代码。</p><p>这意味着调用一个空函数不会引发异常，但是调用一个未被编码的裸函数时，会发生程序异常（裸函数无法产生返回，debug模式下程序会走入“int 3 海洋”）。</p><h3 id="自实现裸函数示例"><a href="#自实现裸函数示例" class="headerlink" title="自实现裸函数示例"></a>自实现裸函数示例</h3><p>如下形式的C语言函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">plus</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> &#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> c = <span class="hljs-number">4</span>;<br><br><span class="hljs-keyword">return</span> a + b + c + x + y + z;<br>&#125;<br></code></pre></td></tr></table></figure><p>改为用裸函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> __declspec(naked) plus(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z) &#123;<br>__asm &#123;<br><span class="hljs-comment">//保存栈基指针</span><br>push ebp<br>mov ebp, esp<br><span class="hljs-comment">//开辟空间存储局部变量</span><br>sub esp, <span class="hljs-number">0x0c</span><br><span class="hljs-comment">//保留现场</span><br>push ebx<br>push esi<br>push edi<br><span class="hljs-comment">//清空栈空间</span><br>lea edi, dword ptr ds:[ebp - <span class="hljs-number">0x0c</span>]<br>mov eax, <span class="hljs-number">0xcccccccc</span><br>mov ecx, <span class="hljs-number">0x03</span><br>rep stosd<br><span class="hljs-comment">//创建局部变量</span><br>mov dword ptr ds:[ebp - <span class="hljs-number">0x04</span>], <span class="hljs-number">2</span><br>mov dword ptr ds:[ebp - <span class="hljs-number">0x08</span>], <span class="hljs-number">3</span><br>mov dword ptr ds:[ebp - <span class="hljs-number">0x0c</span>], <span class="hljs-number">4</span><br><span class="hljs-comment">//累加逻辑</span><br>mov eax, dword ptr ds:[ebp + <span class="hljs-number">0x08</span>]<br>add eax, dword ptr ds:[ebp + <span class="hljs-number">0x0c</span>]<br>add eax, dword ptr ds:[ebp + <span class="hljs-number">0x10</span>]<br>add eax, dword ptr ds:[ebp - <span class="hljs-number">0x04</span>]<br>add eax, dword ptr ds : [ebp - <span class="hljs-number">0x08</span>]<br>add eax, dword ptr ds : [ebp - <span class="hljs-number">0x0c</span>]<br><span class="hljs-comment">//恢复现场</span><br>pop edi<br>pop esi<br>pop ebx<br><span class="hljs-comment">//销毁栈空间</span><br>mov esp, ebp<br>pop ebp<br><span class="hljs-comment">//结果保存在eax, pop eip</span><br>ret<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写代码测试，结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/2/1.jpg"></p><h2 id="真正的程序入口"><a href="#真正的程序入口" class="headerlink" title="真正的程序入口"></a>真正的程序入口</h2><p>编程中我们会习惯将<em>int main()<em>函数作为程序入口，在</em>Windows MFC</em>程序中会将<em>WinMain</em>函数作为程序入口。</p><p>然而这些“入口”都只是逻辑入口，并不是程序启动的真正入口。</p><p>接下来以 <a href="/img/post/2/CallingConvention.exe">示例程序 CallingConvention.exe</a> 进行调试演示，论证这一观点。</p><h2 id="逆向示例"><a href="#逆向示例" class="headerlink" title="逆向示例"></a>逆向示例</h2><p>启动调试器挂载目标程序，看到当前运行在系统领空：</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/2/2.jpg"></p><p>输入快捷键<em>ALT+F9</em>运行至用户代码，可以看到此时来到了<em>EntryPoint</em></p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/2/3.jpg"></p><p>此时才是程序真正的入口，而不是我们的逻辑入口<em>main</em>函数</p><h3 id="寻找main函数"><a href="#寻找main函数" class="headerlink" title="寻找main函数"></a>寻找main函数</h3><p>已知C代码中<em>main</em>函数的原始定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argNum, <span class="hljs-type">void</span>* args[], <span class="hljs-type">void</span>* envir)</span><br></code></pre></td></tr></table></figure><p>即函数声明了三个参数，根据我们之前对<em>cdecl</em>风格的调用约定的猜想，调用<em>main</em>函数大致应该如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> xxx<br><span class="hljs-keyword">push</span> xxx<br><span class="hljs-keyword">push</span> xxx<br><span class="hljs-keyword">call</span> main<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">0x0c</span><br></code></pre></td></tr></table></figure><p>按照此猜想开始单步调试程序，看到如下代码片段，相似度很高：</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/2/4.jpg"></p><p>观察此段代码:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">00401280</span>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[4225FC]<br><span class="hljs-number">00401286</span>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">edx</span>                     <br><span class="hljs-number">00401287</span>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[4225F4]<br>0040128C        <span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span>                     <br><span class="hljs-number">0040128D</span>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[4225F0]<br><span class="hljs-number">00401293</span>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">ecx</span>                     <br><span class="hljs-number">00401294</span>        <span class="hljs-keyword">call</span> callingconvention<span class="hljs-number">.401014</span> <span class="hljs-comment">;压栈了3个参数，栈抬高0xc字节</span><br><span class="hljs-number">00401299</span>        <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>,C                     <span class="hljs-comment">;降低0xc字节栈，平衡了3个参数</span><br></code></pre></td></tr></table></figure><p>步入0x00401014处观察，正是main函数无疑：</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/2/5.jpg"></p><h3 id="核心逻辑分析"><a href="#核心逻辑分析" class="headerlink" title="核心逻辑分析"></a>核心逻辑分析</h3><p>接下来我们开始逐行分析程序行为，首先看到熟悉的<strong>函数序言</strong>:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">00401110</span>        | <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span>                                <br><span class="hljs-number">00401111</span>        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>,<span class="hljs-built_in">esp</span>                             <br><span class="hljs-number">00401113</span>        | <span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span>,<span class="hljs-number">44</span>                            <span class="hljs-comment">; 抬高栈空间  </span><br><span class="hljs-number">00401116</span>        | <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebx</span>                              <span class="hljs-comment">; 保留现场  </span><br><span class="hljs-number">00401117</span>        | <span class="hljs-keyword">push</span> <span class="hljs-built_in">esi</span>                                <br><span class="hljs-number">00401118</span>        | <span class="hljs-keyword">push</span> <span class="hljs-built_in">edi</span>                                <br><span class="hljs-number">00401119</span>        | <span class="hljs-keyword">lea</span> <span class="hljs-built_in">edi</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">44</span>]         <span class="hljs-comment">; 局部变量空间缓冲区  </span><br>0040111C        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>,<span class="hljs-number">11</span>                              <br><span class="hljs-number">00401121</span>        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,CCCCCCCC                        <br><span class="hljs-number">00401126</span>        | <span class="hljs-keyword">rep</span> <span class="hljs-keyword">stosd</span>                             <span class="hljs-comment">; 局部变量空间缓冲区 清理结束  </span><br></code></pre></td></tr></table></figure><p>这个函数的代码逻辑并不复杂，因为我们发现代码并未运行很长段落，就遇到了<strong>函数尾声</strong>。</p><p>函数内又涉及调用其他函数，根据逆向的经验法则，我们并不急于追踪每一个函数调用，先分析在<em>main</em>函数中的逻辑:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">00401128</span>        | <span class="hljs-keyword">push</span> <span class="hljs-number">7</span>                                  |<br>0040112A        | <span class="hljs-keyword">push</span> <span class="hljs-number">6</span>                                  |<br>0040112C        | <span class="hljs-keyword">push</span> <span class="hljs-number">4</span>                                  |<br>0040112E        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>,<span class="hljs-number">3</span>                               |<br><span class="hljs-number">00401133</span>        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>,<span class="hljs-number">1</span>                               |<br><span class="hljs-number">00401138</span>        | <span class="hljs-keyword">call</span> callingconvention<span class="hljs-number">.401019</span>           | 函数调用，可能是fastcall约定<br><span class="hljs-number">0040113D</span>        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-built_in">eax</span>            | 返回值保存在局部变量 a<br><span class="hljs-number">00401140</span>        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>]            | <br><span class="hljs-number">00401143</span>        | <span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span>                                |<br><span class="hljs-number">00401144</span>        | <span class="hljs-keyword">push</span> callingconvention<span class="hljs-number">.</span>41F10C           | 使用 a 和<span class="hljs-string">&quot;%d&quot;</span>作为入参，猜测是printf函数<br><span class="hljs-number">00401149</span>        | <span class="hljs-keyword">call</span> callingconvention<span class="hljs-number">.</span>40B7E0           | 打印计算结果？<br>0040114E        | <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>,<span class="hljs-number">8</span>                               | 外平栈，猜测是cdecl约定<br><span class="hljs-number">00401151</span>        | <span class="hljs-keyword">xor</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">eax</span>                             | main函数返回<span class="hljs-number">0</span>，正常退出<br><span class="hljs-number">00401153</span>        | <span class="hljs-keyword">pop</span> <span class="hljs-built_in">edi</span>                                 | 还原现场<br><span class="hljs-number">00401154</span>        | <span class="hljs-keyword">pop</span> <span class="hljs-built_in">esi</span>                                 |<br><span class="hljs-number">00401155</span>        | <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span>                                 |<br><span class="hljs-number">00401156</span>        | <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>,<span class="hljs-number">44</span>                              | 销毁栈空间<br><span class="hljs-number">00401159</span>        | <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">ebp</span>,<span class="hljs-built_in">esp</span>                             |<br>0040115B        | <span class="hljs-keyword">call</span> callingconvention<span class="hljs-number">.401170</span>           | 编译器栈平衡检测<br><span class="hljs-number">00401160</span>        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>,<span class="hljs-built_in">ebp</span>                             | <br><span class="hljs-number">00401162</span>        | <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span>                                 | 还原帧基指针<br><span class="hljs-number">00401163</span>        | <span class="hljs-keyword">ret</span>                                     | main函数结束<br></code></pre></td></tr></table></figure><p>根据这一轮分析，我们猜测main函数中的核心逻辑就是 <em>callingconvention.401019</em></p><h4 id="核心逻辑大致脉络"><a href="#核心逻辑大致脉络" class="headerlink" title="核心逻辑大致脉络"></a>核心逻辑大致脉络</h4><p>进入核心逻辑函数，此时栈空间分布情况：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">0019FED0                 <span class="hljs-number">0040113D</span>   <span class="hljs-comment">;返回地址</span><br>0019FED4                 <span class="hljs-number">00000004</span>   <span class="hljs-comment">;参数3</span><br>0019FED8                 <span class="hljs-number">00000006</span>   <span class="hljs-comment">;参数4</span><br>0019FEDC                 <span class="hljs-number">00000007</span>   <span class="hljs-comment">;参数5</span><br></code></pre></td></tr></table></figure><p>之前怀疑该函数遵守<em>fastcall</em>调用约定，因此记录下ecx、edx寄存器的值：</p><table><thead><tr><th align="left">寄存器</th><th align="right">值</th></tr></thead><tbody><tr><td align="left">ecx</td><td align="right">00000001</td></tr><tr><td align="left">edx</td><td align="right">00000003</td></tr></tbody></table><p>将函数的序言部分、尾声部分删减掉不看，直接观察函数的运行逻辑：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">004010BA        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>],<span class="hljs-built_in">edx</span>            | 第二个参数保存为局部变量b<br>004010BD        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-built_in">ecx</span>            | 第一个参数保存为局部变量a<br>004010C0        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>+<span class="hljs-number">8</span>]            | <span class="hljs-built_in">eax</span> = 参数<span class="hljs-number">3</span><br>004010C3        | <span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span>                                |<br>004010C4        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]            | <span class="hljs-built_in">ecx</span> = b<br>004010C7        | <span class="hljs-keyword">push</span> <span class="hljs-built_in">ecx</span>                                |<br>004010C8        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>]            | <span class="hljs-built_in">edx</span> = a<br>004010CB        | <span class="hljs-keyword">push</span> <span class="hljs-built_in">edx</span>                                |<br>004010CC        | <span class="hljs-keyword">call</span> callingconvention<span class="hljs-number">.</span>40101E           | 猜测:func1(a, b, 参数<span class="hljs-number">3</span>)<br>004010D1        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>-C],<span class="hljs-built_in">eax</span>            | 返回值保存为局部变量c<br>004010D4        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]            | <span class="hljs-built_in">eax</span> = b<br>004010D7        | <span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span>                                |<br>004010D8        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>]            | <span class="hljs-built_in">ecx</span> = a<br>004010<span class="hljs-built_in">DB</span>        | <span class="hljs-keyword">push</span> <span class="hljs-built_in">ecx</span>                                |<br>004010DC        | <span class="hljs-keyword">call</span> callingconvention<span class="hljs-number">.401005</span>           | 猜测:func2(a, b)<br>004010E1        | <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>,<span class="hljs-number">8</span>                               |<br>004010E4        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">10</span>],<span class="hljs-built_in">eax</span>           | 返回值保存为局部变量d<br>004010E7        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">10</span>]           | <span class="hljs-built_in">edx</span> = d<br>004010EA        | <span class="hljs-keyword">push</span> <span class="hljs-built_in">edx</span>                                |<br>004010EB        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>-C]            | <span class="hljs-built_in">eax</span> = c<br>004010EE        | <span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span>                                |<br>004010EF        | <span class="hljs-keyword">call</span> callingconvention<span class="hljs-number">.401005</span>           | 猜测:func3(c, d)<br>004010F4        | <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>,<span class="hljs-number">8</span>                               |<br></code></pre></td></tr></table></figure><p>此时需要分别逆向func1\func2\func3这三个子函数的逻辑，我们先记录下子函数地址：</p><ol><li>callingconvention.40101E ; func1</li><li>callingconvention.401005 ; func2</li><li>callingconvention.401005 ; func3</li></ol><p>发现func2与func3函数地址相同，实际上是同一个函数的多次调用而已。</p><h4 id="callingconvention-40101E-func1-分析"><a href="#callingconvention-40101E-func1-分析" class="headerlink" title="callingconvention.40101E func1 分析"></a>callingconvention.40101E func1 分析</h4><p>步入func1，记录此时栈空间分布：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">0019FE60                 004010D1 <span class="hljs-comment">; 返回004010D1,mov dword ptr ss:[ebp-C],eax</span><br>0019FE64                 <span class="hljs-number">00000001</span> <span class="hljs-comment">; 参数1  </span><br>0019FE68                 <span class="hljs-number">00000003</span> <span class="hljs-comment">; 参数2  </span><br>0019FE6C                 <span class="hljs-number">00000004</span> <span class="hljs-comment">; 参数3 </span><br></code></pre></td></tr></table></figure><p>同样删减掉函数尾声与序言，观察核心逻辑：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">00401078</span>        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>+<span class="hljs-number">8</span>]            | <span class="hljs-built_in">eax</span>  = 参数<span class="hljs-number">1</span><br>0040107B        | <span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>+C]            | <span class="hljs-built_in">eax</span> += 参数<span class="hljs-number">2</span><br>0040107E        | <span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>+<span class="hljs-number">10</span>]           | <span class="hljs-built_in">eax</span> += 参数<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>可知func1是个累加函数，将3个参数相加后返回，观察其函数尾声，可知是遵循<em>stdcall</em>调用约定, 即参数从右到左入栈、内部平栈:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">00401084</span>        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>,<span class="hljs-built_in">ebp</span>                             |<br><span class="hljs-number">00401086</span>        | <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span>                                 |<br><span class="hljs-number">00401087</span>        | <span class="hljs-keyword">ret</span> C                                   | 内平栈<br></code></pre></td></tr></table></figure><p>预期当次调用返回时eax的值等于0x08，观测结果与预期一致:</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/2/6.jpg"></p><h4 id="callingconvention-401005-func2-分析"><a href="#callingconvention-401005-func2-分析" class="headerlink" title="callingconvention.401005 func2 分析"></a>callingconvention.401005 func2 分析</h4><p>步入func1，记录此时栈空间分布：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">0019FE64                 004010E1 <span class="hljs-comment">; 返回004010E1,add esp,8</span><br>0019FE68                 <span class="hljs-number">00000001</span> <span class="hljs-comment">; 参数1  </span><br>0019FE6C                 <span class="hljs-number">00000003</span> <span class="hljs-comment">; 参数2  </span><br></code></pre></td></tr></table></figure><p>同样删减掉函数尾声与序言，观察核心逻辑：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">00401048</span>        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>+<span class="hljs-number">8</span>]            | <span class="hljs-built_in">eax</span>  = 参数<span class="hljs-number">1</span><br>0040104B        | <span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>+C]            | <span class="hljs-built_in">eax</span> += 参数<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>可知func2也只是个累加函数，根据其尾声与入参方式，可知是遵循cdecl约定：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">00401051</span>        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>,<span class="hljs-built_in">ebp</span>                             |<br><span class="hljs-number">00401053</span>        | <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span>                                 |<br><span class="hljs-number">00401054</span>        | <span class="hljs-keyword">ret</span>                                     | 外平栈<br></code></pre></td></tr></table></figure><p>预期当次调用返回时eax的值等于0x04，观测结果与预期一致:</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/2/7.jpg"></p><h4 id="回到核心逻辑"><a href="#回到核心逻辑" class="headerlink" title="回到核心逻辑"></a>回到核心逻辑</h4><p>我们来看看核心逻辑剩余未被分析的部分:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">004010E4        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">10</span>],<span class="hljs-built_in">eax</span>           | 返回值保存为局部变量d=<span class="hljs-number">4</span><br>004010E7        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">10</span>]           | <span class="hljs-built_in">edx</span> = d = <span class="hljs-number">4</span><br>004010EA        | <span class="hljs-keyword">push</span> <span class="hljs-built_in">edx</span>                                |<br>004010EB        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ss</span>:[<span class="hljs-built_in">ebp</span>-C]            | <span class="hljs-built_in">eax</span> = c = <span class="hljs-number">8</span><br>004010EE        | <span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span>                                |<br>004010EF        | <span class="hljs-keyword">call</span> callingconvention<span class="hljs-number">.401005</span>           | 累加(c, d)<br>004010F4        | <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>,<span class="hljs-number">8</span>                               | 预期 <span class="hljs-built_in">eax</span> = <span class="hljs-number">0xc</span><br></code></pre></td></tr></table></figure><p>直接执行，观测预期与结果一致:</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/2/8.jpg"></p><p>此时函数核心逻辑运行结束，观测函数尾声，验证我们之前的猜想，这个函数遵循fastcall约定：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">004010F7        | <span class="hljs-keyword">pop</span> <span class="hljs-built_in">edi</span>                                 |<br>004010F8        | <span class="hljs-keyword">pop</span> <span class="hljs-built_in">esi</span>                                 |<br>004010F9        | <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span>                                 |<br>004010FA        | <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>,<span class="hljs-number">50</span>                              |<br>004010FD        | <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">ebp</span>,<span class="hljs-built_in">esp</span>                             |<br>004010FF        | <span class="hljs-keyword">call</span> callingconvention<span class="hljs-number">.401170</span>           |<br><span class="hljs-number">00401104</span>        | <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>,<span class="hljs-built_in">ebp</span>                             |<br><span class="hljs-number">00401106</span>        | <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span>                                 |<br><span class="hljs-number">00401107</span>        | <span class="hljs-keyword">ret</span> C                                   | 内平栈，降低<span class="hljs-number">12</span>字节<br></code></pre></td></tr></table></figure><p>该函数使用ecx、edx寄存器，并在尾声中平栈12字节，因此可以确定是遵循fastcall约定的函数</p><h3 id="逆向分析结束"><a href="#逆向分析结束" class="headerlink" title="逆向分析结束"></a>逆向分析结束</h3><p>main函数接下来打印了计算结果，与我们分析的一致，使用了<em>printf</em>函数输出结果：12</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/2/9.jpg"></p><p>程序运行至此结束，我们完成了对这个示例程序的逆向分析。</p><p>接下来就要根据分析结论进行代码还原了。</p><h3 id="反汇编还原为C代码"><a href="#反汇编还原为C代码" class="headerlink" title="反汇编还原为C代码"></a>反汇编还原为C代码</h3><p>根据逆向分析结果，尝试还原C代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> __stdcall <span class="hljs-title function_">func1</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> x3)</span> &#123;<br><span class="hljs-keyword">return</span> x + x2 + x3;<br>&#125;<br><br><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> x2)</span> &#123;<br><span class="hljs-keyword">return</span> x + x2;<br>&#125;<br><br><span class="hljs-type">int</span> __fastcall <span class="hljs-title function_">plus</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> x3, <span class="hljs-type">int</span> x4, <span class="hljs-type">int</span> x5)</span> &#123;<br><span class="hljs-type">int</span> a = x;<br><span class="hljs-type">int</span> b = x2;<br><span class="hljs-type">int</span> c = func1(a, b, x3);<br><span class="hljs-type">int</span> d = func2(a, b);<br><span class="hljs-keyword">return</span> func2(c, d);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> numbs, <span class="hljs-type">char</span>* args[])</span> &#123;<br><span class="hljs-type">int</span> a = plus(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\r\n&quot;</span>, a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>检查输出结果与示例程序输出是否一致:</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/2/10.jpg"></p><p>至此，逆向分析结束。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>示例程序虽然简单，但是使用到的分析技巧却是真实逆向工程中常用的分析技术。</p><p>读者应自行下载示例程序并动手逆向，在过程中不断思考才是提升自身逆向水平的唯一道路。</p>]]></content>
    
    
    <categories>
      
      <category>上善若水</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>C</tag>
      
      <tag>调用约定</tag>
      
      <tag>堆栈平衡</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译64位程序时使用汇编的方法总结</title>
    <link href="/blogs/2021110513150017806.html"/>
    <url>/blogs/2021110513150017806.html</url>
    
    <content type="html"><![CDATA[<h2 id="转载声明"><a href="#转载声明" class="headerlink" title="转载声明"></a>转载声明</h2><div class="note note-success">            <p>该博文转载自<em>看雪论坛</em></p><p>本文作者:尼古拉斯大拿</p><p>原文地址:<a href="https://bbs.kanxue.com/thread-270137.htm">编译64位程序时使用汇编的方法总结</a></p>          </div><h2 id="文中所用的环境"><a href="#文中所用的环境" class="headerlink" title="文中所用的环境"></a>文中所用的环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">win10 20H2(19042.928)<br>Visual Studio 2019(16.11.5)<br></code></pre></td></tr></table></figure><h2 id="64位程序开发中使用汇编的两（三）种方法"><a href="#64位程序开发中使用汇编的两（三）种方法" class="headerlink" title="64位程序开发中使用汇编的两（三）种方法"></a>64位程序开发中使用汇编的两（三）种方法</h2><h3 id="第一种：通过添加obj文件"><a href="#第一种：通过添加obj文件" class="headerlink" title="第一种：通过添加obj文件"></a>第一种：通过添加obj文件</h3><p>编写汇编代码。</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/3/1.png"></p><p>通过ml64编译得到obj</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ml64 /c MyAdd.asm<br></code></pre></td></tr></table></figure><p>&#x2F;c是只编译不链接，钱老师n久之前讲过的知识。</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/3/2.png"></p><p>把obj文件添加（拖拽）到工程</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/3/3.png"></p><p>测试使用汇编中的函数</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/3/4.png"></p><h3 id="第二种：联合编译"><a href="#第二种：联合编译" class="headerlink" title="第二种：联合编译"></a>第二种：联合编译</h3><h4 id="联合编译的方法1"><a href="#联合编译的方法1" class="headerlink" title="联合编译的方法1"></a>联合编译的方法1</h4><h5 id="添加-asm文件到工程"><a href="#添加-asm文件到工程" class="headerlink" title="添加.asm文件到工程"></a>添加.asm文件到工程</h5><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/3/5.png"></p><h5 id="对添加的-asm文件属性做设置"><a href="#对添加的-asm文件属性做设置" class="headerlink" title="对添加的.asm文件属性做设置"></a>对添加的.asm文件属性做设置</h5><p>默认添加的是不参与生成的，需要手动设置一下</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/3/6.png"></p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/3/7.png"></p><p>选择自定义生成工具后点击应用，会出现新的选项。</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/3/8.png"></p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/3/9.png"></p><p>在“自定义生成工具”中设置“命令行”和“输出文件”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">//命令行栏 内容<br>ml64 /c %(fileName).asm<br>//输入栏 内容<br><span class="hljs-meta prompt_">%</span><span class="language-bash">(fileName).obj;%(Outputs)</span><br></code></pre></td></tr></table></figure><p>输入完毕点击确定，然后编译工程测试下，会看到输出了 .obj文件。</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/3/10.png"></p><h5 id="测试使用汇编中的函数"><a href="#测试使用汇编中的函数" class="headerlink" title="测试使用汇编中的函数"></a>测试使用汇编中的函数</h5><p>声明.asm中的函数并编写测试代码使用它。</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/3/11.png"></p><p>测试结果正常，当然还有一种类似的方法，更为简单</p><h4 id="联合编译的方法2"><a href="#联合编译的方法2" class="headerlink" title="联合编译的方法2"></a>联合编译的方法2</h4><h5 id="修改工程生成依赖项"><a href="#修改工程生成依赖项" class="headerlink" title="修改工程生成依赖项"></a>修改工程生成依赖项</h5><p>右键点击工程名，在弹出的菜单选择“生成依赖项”—-&gt; “生成自定义”</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/3/12.png"></p><p>勾选 masm后确定</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/3/13.png"></p><h5 id="添加-asm文件编写代码，声明-asm中的函数，使用测试"><a href="#添加-asm文件编写代码，声明-asm中的函数，使用测试" class="headerlink" title="添加.asm文件编写代码，声明.asm中的函数，使用测试"></a>添加.asm文件编写代码，声明.asm中的函数，使用测试</h5><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/3/14.png"></p><p>这里可以在解决方案资源管理器里，右键选中添加的.asm文件，然后在弹出菜单中选择“属性”，查看下“项类型”是否为“Microsoft Macro Assembler”，如果不是，那需要手动设置下。一般情况下在添加了生成自定义，这时候是不需要自己再对文件设置了。</p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/3/15.png"></p><p><img src="https://cdn.jsdelivr.net/gh/DubheHub/dubhehub.github.io@master/img/post/3/16.png"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>我自己更倾向于最后一种方法，原因就是简单，之后再添加.asm文件不需要额外的设置了。哪里写的不对的请多多指正。<br>2021年11月5日13点14分</p>]]></content>
    
    
    <categories>
      
      <category>VS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
      <tag>vistual studio</tag>
      
      <tag>编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JCC速查</title>
    <link href="/blogs/2015120616481352488.html"/>
    <url>/blogs/2015120616481352488.html</url>
    
    <content type="html"><![CDATA[<h2 id="速查表"><a href="#速查表" class="headerlink" title="速查表"></a>速查表</h2><table><thead><tr><th align="left">指令</th><th align="center">描述</th><th align="right">标志寄存器</th></tr></thead><tbody><tr><td align="left">JE, JZ</td><td align="center">结果为零则跳转(相等时跳转)</td><td align="right">ZF&#x3D;1</td></tr><tr><td align="left">JNE, JNZ</td><td align="center">结果不为零则跳转(不相等时跳转)</td><td align="right">ZF&#x3D;0</td></tr><tr><td align="left">JS</td><td align="center">结果为负则跳转</td><td align="right">SF&#x3D;1</td></tr><tr><td align="left">JNS</td><td align="center">结果为非负则跳转</td><td align="right">SF&#x3D;0</td></tr><tr><td align="left">JP, JPE</td><td align="center">结果中1的个数为偶数则跳转</td><td align="right">PF&#x3D;1</td></tr><tr><td align="left">JNP, JPO</td><td align="center">结果中1的个数为偶数则跳转</td><td align="right">PF&#x3D;0</td></tr><tr><td align="left">JO</td><td align="center">结果溢出了则跳转</td><td align="right">OF&#x3D;1</td></tr><tr><td align="left">JNO</td><td align="center">结果没有溢出则跳转</td><td align="right">OF&#x3D;0</td></tr><tr><td align="left">JB, JNAE</td><td align="center">小于则跳转 (无符号数)</td><td align="right">CF&#x3D;1</td></tr><tr><td align="left">JNB, JAE</td><td align="center">大于等于则跳转 (无符号数)</td><td align="right">CF&#x3D;0</td></tr><tr><td align="left">JBE, JNA</td><td align="center">小于等于则跳转 (无符号数)</td><td align="right">CF&#x3D;1 or ZF&#x3D;1</td></tr><tr><td align="left">JNBE, JA</td><td align="center">大于则跳转(无符号数)</td><td align="right">CF&#x3D;0 and ZF&#x3D;0</td></tr><tr><td align="left">JL, JNGE</td><td align="center">小于则跳转 (<strong>有符号数</strong>)</td><td align="right">SF≠ OF</td></tr><tr><td align="left">JNL, JGE</td><td align="center">大于等于则跳转 (<strong>有符号数</strong>)</td><td align="right">SF&#x3D;OF</td></tr><tr><td align="left">JLE, JNG</td><td align="center">小于等于则跳转 (<strong>有符号数</strong>)</td><td align="right">ZF&#x3D;1 or SF≠ OF</td></tr><tr><td align="left">JNLE, JG</td><td align="center">大于则跳转(<strong>有符号数</strong>)</td><td align="right">ZF&#x3D;0 and SF&#x3D;OF</td></tr></tbody></table><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol><li>JE, JZ 结果为零则跳转(相等时跳转) ZF&#x3D;1</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CL</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">AL</span>,<span class="hljs-built_in">CL</span><br><span class="hljs-keyword">JE</span> <span class="hljs-number">0X0040102B</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>x86汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
      <tag>JCC</tag>
      
      <tag>标志寄存器</tag>
      
      <tag>EFLAGS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
