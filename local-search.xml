<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C语言逆向(1)</title>
    <link href="/2023/12/08/2/"/>
    <url>/2023/12/08/2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是一篇C语言逆向入门教学，会介绍如何从一个简单的C语言程序开始接触逆向工程技术。</p></blockquote><h2 id="C风格函数"><a href="#C风格函数" class="headerlink" title="C风格函数"></a>C风格函数</h2><p>一个标准的C语言程序“HelloWorld.c”可能会写作如下结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argNums, <span class="hljs-type">char</span>* args[])</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在32位汇编层面，我们有如下函数调用约定：</p><table><thead><tr><th align="left">约定</th><th align="center">参数传递</th><th align="right">栈平衡</th></tr></thead><tbody><tr><td align="left">cdecl</td><td align="center">从右到左依次压栈</td><td align="right">外平栈(调用者负责平衡栈)</td></tr><tr><td align="left">stdcall</td><td align="center">从右到左依次压栈</td><td align="right">内平栈(函数内部平衡栈，无需调用者参与)</td></tr><tr><td align="left">fastcall</td><td align="center">前两个参数依次放入ECX,EDX寄存器，其他参数从右到左依次压栈</td><td align="right">内平栈</td></tr></tbody></table><p>在x64汇编环境下，仅有fastcall一种调用约定，前四个参数依次放入RCX,RDX,R8,R9四个寄存器，其他参数从右到左依次压栈，内平栈。</p><h2 id="Windows系统的栈设计"><a href="#Windows系统的栈设计" class="headerlink" title="Windows系统的栈设计"></a>Windows系统的栈设计</h2><p>栈空间的总量由系统分配，从高内存向低内存扩展，即内存减少为栈抬高的方向。</p><h3 id="函数序言"><a href="#函数序言" class="headerlink" title="函数序言"></a>函数序言</h3><p>多数C风格函数的入口会有如下代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br></code></pre></td></tr></table></figure><p>ebp存储了栈底空间地址，此代码保存了之前的栈底，确保栈帧之间的连续性。</p><p>这段代码也被称为<strong>函数序言</strong>， 需要注意的是，不一定所有的C语言函数都严格遵守这个规则。</p><h3 id="栈空间"><a href="#栈空间" class="headerlink" title="栈空间"></a>栈空间</h3><h4 id="栈帧指针"><a href="#栈帧指针" class="headerlink" title="栈帧指针"></a>栈帧指针</h4><p>esp寄存器在不进行人为干涉的情况下，始终存储栈顶地址。</p><p>使用pop，push，call，ret等指令时，都会影响esp寄存器的值。</p><p>esp寄存器也被称为<strong>栈帧指针</strong></p><h4 id="帧基指针"><a href="#帧基指针" class="headerlink" title="帧基指针"></a>帧基指针</h4><p>由于ebp寄存器始终存储栈底，即栈帧的基地址，所以ebp寄存器也被称为<strong>帧基指针</strong>。</p><p>常见的使用方式：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">ebp</span>] <span class="hljs-comment">;获取上一帧的帧基地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">ebp</span>+<span class="hljs-number">0x04</span>] <span class="hljs-comment">;获取函数返回地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">ebp</span>+<span class="hljs-number">0x08</span>] <span class="hljs-comment">;获取函数的第一个参数</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0x04</span>] <span class="hljs-comment">;获取函数的第一个局部变量</span><br></code></pre></td></tr></table></figure><h4 id="局部变量缓冲区"><a href="#局部变量缓冲区" class="headerlink" title="局部变量缓冲区"></a>局部变量缓冲区</h4><p>在函数序言结束后，如果函数内部需要使用局部变量，一般会在栈上开辟局部变量的空间。</p><p>部份编译器在debug模式下编译C语言代码时，会在局部变量空间内填充0xCC，即int 3中断。</p><p>形如下面格式：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">0x40</span> <span class="hljs-comment">;开辟64字节的局部变量空间</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebx</span>      <br><span class="hljs-keyword">push</span> <span class="hljs-built_in">esi</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">edi</span>      <span class="hljs-comment">;保存现场</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">edi</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">ebp</span> - <span class="hljs-number">0x40</span>]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">0xcccccccc</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">0x10</span><br><span class="hljs-keyword">rep</span> <span class="hljs-keyword">stosd</span>     <span class="hljs-comment">;将开辟出的64字节空间全部用0xcc填充</span><br></code></pre></td></tr></table></figure><h3 id="函数尾声"><a href="#函数尾声" class="headerlink" title="函数尾声"></a>函数尾声</h3><p>在函数即将结束时，会销毁开辟的栈空间，并将帧指针与帧基指针还原到函数调用时的状态。</p><p>形如下面格式：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">pop</span> <span class="hljs-built_in">edi</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">esi</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>, <span class="hljs-built_in">ebp</span> <span class="hljs-comment">;销毁栈空间</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span>      <span class="hljs-comment">;还原帧基指针</span><br><span class="hljs-keyword">ret</span>          <span class="hljs-comment">;变形即 pop eip</span><br></code></pre></td></tr></table></figure><p>这样的模板代码也被称为<strong>函数尾声</strong>，需要注意的是，与<strong>函数序言</strong>相同，并不是所有函数都严格遵守这个形式。</p><h3 id="栈平衡"><a href="#栈平衡" class="headerlink" title="栈平衡"></a>栈平衡</h3><p><strong>cdecl</strong>风格的函数一般定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> __cdecl <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>;<br></code></pre></td></tr></table></figure><p>该函数由调用者平衡栈，即:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">ebp</span> - <span class="hljs-number">0x04</span>]<br><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebx</span>            <span class="hljs-comment">;参数入栈</span><br><span class="hljs-keyword">call</span> func           <span class="hljs-comment">;调用函数</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">0x04</span>       <span class="hljs-comment">;平衡栈</span><br></code></pre></td></tr></table></figure><h2 id="空函数与裸函数区别"><a href="#空函数与裸函数区别" class="headerlink" title="空函数与裸函数区别"></a>空函数与裸函数区别</h2><p>在C语言中，空函数与裸函数对编译器而言完全不同，如下形式的两个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> __declspec(naked) naked_func(<span class="hljs-type">int</span> i)&#123;<br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">empty_func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>被 <em>__declspec(naked)</em> 修饰的函数 <em>naked_func</em> 在编译阶段不会生成任何汇编代码，所有工作都需要编码者自行实现。</p><p>而空函数 <em>empty_func</em> 中虽然也没有写任何程序逻辑，但是编译器会为其生成 <strong>函数序言</strong> 、 <strong>函数尾声</strong> 等模板代码。</p><p>这意味着调用一个空函数不会引发异常，但是调用一个未被编码的裸函数时，会发生程序异常（裸函数无法产生返回，debug模式下程序会走入“int 3 海洋”）。</p><h2 id="真正的程序入口"><a href="#真正的程序入口" class="headerlink" title="真正的程序入口"></a>真正的程序入口</h2><h2 id="逆向示例"><a href="#逆向示例" class="headerlink" title="逆向示例"></a>逆向示例</h2><h3 id="寻找程序入口"><a href="#寻找程序入口" class="headerlink" title="寻找程序入口"></a>寻找程序入口</h3><h3 id="定位核心逻辑函数"><a href="#定位核心逻辑函数" class="headerlink" title="定位核心逻辑函数"></a>定位核心逻辑函数</h3><h3 id="反汇编还原为C代码"><a href="#反汇编还原为C代码" class="headerlink" title="反汇编还原为C代码"></a>反汇编还原为C代码</h3>]]></content>
    
    
    <categories>
      
      <category>x86汇编</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>C</tag>
      
      <tag>调用约定</tag>
      
      <tag>堆栈平衡</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译64位程序时使用汇编的方法总结</title>
    <link href="/2023/12/07/3/"/>
    <url>/2023/12/07/3/</url>
    
    <content type="html"><![CDATA[<h2 id="转载声明"><a href="#转载声明" class="headerlink" title="转载声明"></a>转载声明</h2><p>该博文转载自<em>看雪论坛</em>，原文地址如下：</p><p><a href="https://bbs.kanxue.com/thread-270137.htm">编译64位程序时使用汇编的方法总结 作者:尼古拉斯大拿</a></p><h2 id="文中所用的环境"><a href="#文中所用的环境" class="headerlink" title="文中所用的环境"></a>文中所用的环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">win10 20H2(19042.928)<br>Visual Studio 2019(16.11.5)<br></code></pre></td></tr></table></figure><h2 id="64位程序开发中使用汇编的两（三）种方法"><a href="#64位程序开发中使用汇编的两（三）种方法" class="headerlink" title="64位程序开发中使用汇编的两（三）种方法"></a>64位程序开发中使用汇编的两（三）种方法</h2><h3 id="第一种：通过添加obj文件"><a href="#第一种：通过添加obj文件" class="headerlink" title="第一种：通过添加obj文件"></a>第一种：通过添加obj文件</h3><p>编写汇编代码。</p><p><img src="/img/post/3/1.png"></p><p>通过ml64编译得到obj</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ml64 /c MyAdd.asm<br></code></pre></td></tr></table></figure><p>&#x2F;c是只编译不链接，钱老师n久之前讲过的知识。</p><p><img src="/img/post/3/2.png"></p><p>把obj文件添加（拖拽）到工程</p><p><img src="/img/post/3/3.png"></p><p>测试使用汇编中的函数</p><p><img src="/img/post/3/4.png"></p><h3 id="第二种：联合编译"><a href="#第二种：联合编译" class="headerlink" title="第二种：联合编译"></a>第二种：联合编译</h3><h4 id="联合编译的方法1"><a href="#联合编译的方法1" class="headerlink" title="联合编译的方法1"></a>联合编译的方法1</h4><h5 id="添加-asm文件到工程"><a href="#添加-asm文件到工程" class="headerlink" title="添加.asm文件到工程"></a>添加.asm文件到工程</h5><p><img src="/img/post/3/5.png"></p><h5 id="对添加的-asm文件属性做设置"><a href="#对添加的-asm文件属性做设置" class="headerlink" title="对添加的.asm文件属性做设置"></a>对添加的.asm文件属性做设置</h5><p>默认添加的是不参与生成的，需要手动设置一下</p><p><img src="/img/post/3/6.png"></p><p><img src="/img/post/3/7.png"></p><p>选择自定义生成工具后点击应用，会出现新的选项。</p><p><img src="/img/post/3/8.png"></p><p><img src="/img/post/3/9.png"></p><p>在“自定义生成工具”中设置“命令行”和“输出文件”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">//命令行栏 内容<br>ml64 /c %(fileName).asm<br>//输入栏 内容<br><span class="hljs-meta prompt_">%</span><span class="language-bash">(fileName).obj;%(Outputs)</span><br></code></pre></td></tr></table></figure><p>输入完毕点击确定，然后编译工程测试下，会看到输出了 .obj文件。</p><p><img src="/img/post/3/10.png"></p><h5 id="测试使用汇编中的函数"><a href="#测试使用汇编中的函数" class="headerlink" title="测试使用汇编中的函数"></a>测试使用汇编中的函数</h5><p>声明.asm中的函数并编写测试代码使用它。</p><p><img src="/img/post/3/11.png"></p><p>测试结果正常，当然还有一种类似的方法，更为简单</p><h4 id="联合编译的方法2"><a href="#联合编译的方法2" class="headerlink" title="联合编译的方法2"></a>联合编译的方法2</h4><h5 id="修改工程生成依赖项"><a href="#修改工程生成依赖项" class="headerlink" title="修改工程生成依赖项"></a>修改工程生成依赖项</h5><p>右键点击工程名，在弹出的菜单选择“生成依赖项”—-&gt; “生成自定义”</p><p><img src="/img/post/3/12.png"></p><p>勾选 masm后确定</p><p><img src="/img/post/3/13.png"></p><h5 id="添加-asm文件编写代码，声明-asm中的函数，使用测试"><a href="#添加-asm文件编写代码，声明-asm中的函数，使用测试" class="headerlink" title="添加.asm文件编写代码，声明.asm中的函数，使用测试"></a>添加.asm文件编写代码，声明.asm中的函数，使用测试</h5><p><img src="/img/post/3/14.png"></p><p>这里可以在解决方案资源管理器里，右键选中添加的.asm文件，然后在弹出菜单中选择“属性”，查看下“项类型”是否为“Microsoft Macro Assembler”，如果不是，那需要手动设置下。一般情况下在添加了生成自定义，这时候是不需要自己再对文件设置了。</p><p><img src="/img/post/3/15.png"></p><p><img src="/img/post/3/16.png"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>我自己更倾向于最后一种方法，原因就是简单，之后再添加.asm文件不需要额外的设置了。哪里写的不对的请多多指正。<br>2021年11月5日13点14分</p>]]></content>
    
    
    <categories>
      
      <category>x86汇编</category>
      
      <category>VS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
      <tag>vistual studio</tag>
      
      <tag>编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JCC速查</title>
    <link href="/2015/12/06/1/"/>
    <url>/2015/12/06/1/</url>
    
    <content type="html"><![CDATA[<h2 id="速查表"><a href="#速查表" class="headerlink" title="速查表"></a>速查表</h2><table><thead><tr><th align="left">指令</th><th align="center">描述</th><th align="right">标志寄存器</th></tr></thead><tbody><tr><td align="left">JE, JZ</td><td align="center">结果为零则跳转(相等时跳转)</td><td align="right">ZF&#x3D;1</td></tr><tr><td align="left">JNE, JNZ</td><td align="center">结果不为零则跳转(不相等时跳转)</td><td align="right">ZF&#x3D;0</td></tr><tr><td align="left">JS</td><td align="center">结果为负则跳转</td><td align="right">SF&#x3D;1</td></tr><tr><td align="left">JNS</td><td align="center">结果为非负则跳转</td><td align="right">SF&#x3D;0</td></tr><tr><td align="left">JP, JPE</td><td align="center">结果中1的个数为偶数则跳转</td><td align="right">PF&#x3D;1</td></tr><tr><td align="left">JNP, JPO</td><td align="center">结果中1的个数为偶数则跳转</td><td align="right">PF&#x3D;0</td></tr><tr><td align="left">JO</td><td align="center">结果溢出了则跳转</td><td align="right">OF&#x3D;1</td></tr><tr><td align="left">JNO</td><td align="center">结果没有溢出则跳转</td><td align="right">OF&#x3D;0</td></tr><tr><td align="left">JB, JNAE</td><td align="center">小于则跳转 (无符号数)</td><td align="right">CF&#x3D;1</td></tr><tr><td align="left">JNB, JAE</td><td align="center">大于等于则跳转 (无符号数)</td><td align="right">CF&#x3D;0</td></tr><tr><td align="left">JBE, JNA</td><td align="center">小于等于则跳转 (无符号数)</td><td align="right">CF&#x3D;1 or ZF&#x3D;1</td></tr><tr><td align="left">JNBE, JA</td><td align="center">大于则跳转(无符号数)</td><td align="right">CF&#x3D;0 and ZF&#x3D;0</td></tr><tr><td align="left">JL, JNGE</td><td align="center">小于则跳转 (<strong>有符号数</strong>)</td><td align="right">SF≠ OF</td></tr><tr><td align="left">JNL, JGE</td><td align="center">大于等于则跳转 (<strong>有符号数</strong>)</td><td align="right">SF&#x3D;OF</td></tr><tr><td align="left">JLE, JNG</td><td align="center">小于等于则跳转 (<strong>有符号数</strong>)</td><td align="right">ZF&#x3D;1 or SF≠ OF</td></tr><tr><td align="left">JNLE, JG</td><td align="center">大于则跳转(<strong>有符号数</strong>)</td><td align="right">ZF&#x3D;0 and SF&#x3D;OF</td></tr></tbody></table><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol><li>JE, JZ 结果为零则跳转(相等时跳转) ZF&#x3D;1</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CL</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">AL</span>,<span class="hljs-built_in">CL</span><br><span class="hljs-keyword">JE</span> <span class="hljs-number">0X0040102B</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>x86汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
      <tag>JCC</tag>
      
      <tag>标志寄存器</tag>
      
      <tag>EFLAGS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
